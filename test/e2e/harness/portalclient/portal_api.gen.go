// Package portalclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package portalclient

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	PortalAccessTokenScopes = "portalAccessToken.Scopes"
)

// Defines values for AbsoluteTimeRangeDtoType.
const (
	Absolute AbsoluteTimeRangeDtoType = "absolute"
)

// Defines values for ApiVisibility.
const (
	ApiVisibilityPrivate ApiVisibility = "private"
	ApiVisibilityPublic  ApiVisibility = "public"
)

// Defines values for ApiApplicationRegistrationStatus.
const (
	ApiApplicationRegistrationStatusApproved ApiApplicationRegistrationStatus = "approved"
	ApiApplicationRegistrationStatusPending  ApiApplicationRegistrationStatus = "pending"
	ApiApplicationRegistrationStatusRejected ApiApplicationRegistrationStatus = "rejected"
	ApiApplicationRegistrationStatusRevoked  ApiApplicationRegistrationStatus = "revoked"
)

// Defines values for ApiFilterField.
const (
	ApiFilterFieldApi ApiFilterField = "api"
)

// Defines values for ApiSpecType.
const (
	Asyncapi ApiSpecType = "asyncapi"
	Oas2     ApiSpecType = "oas2"
	Oas3     ApiSpecType = "oas3"
)

// Defines values for ApplicationFilterField.
const (
	Application ApplicationFilterField = "application"
)

// Defines values for AuthStrategyClientCredentialsCredentialType.
const (
	AuthStrategyClientCredentialsCredentialTypeClientCredentials            AuthStrategyClientCredentialsCredentialType = "client_credentials"
	AuthStrategyClientCredentialsCredentialTypeSelfManagedClientCredentials AuthStrategyClientCredentialsCredentialType = "self_managed_client_credentials"
)

// Defines values for AuthStrategyKeyAuthCredentialType.
const (
	AuthStrategyKeyAuthCredentialTypeKeyAuth AuthStrategyKeyAuthCredentialType = "key_auth"
)

// Defines values for DocumentFormatContentTypeEnum.
const (
	Applicationjson                        DocumentFormatContentTypeEnum = "application/json"
	ApplicationvndKonnectDocumentNodesJson DocumentFormatContentTypeEnum = "application/vnd.konnect.document-nodes+json"
	Textmarkdown                           DocumentFormatContentTypeEnum = "text/markdown"
)

// Defines values for FilterType.
const (
	In    FilterType = "in"
	NotIn FilterType = "not_in"
)

// Defines values for GetApiRegistrationResponseStatus.
const (
	GetApiRegistrationResponseStatusApproved GetApiRegistrationResponseStatus = "approved"
	GetApiRegistrationResponseStatusPending  GetApiRegistrationResponseStatus = "pending"
	GetApiRegistrationResponseStatusRejected GetApiRegistrationResponseStatus = "rejected"
	GetApiRegistrationResponseStatusRevoked  GetApiRegistrationResponseStatus = "revoked"
)

// Defines values for InvalidParameterChoiceItemRule.
const (
	Enum InvalidParameterChoiceItemRule = "enum"
)

// Defines values for InvalidParameterDependentItemRule.
const (
	DependentFields InvalidParameterDependentItemRule = "dependent_fields"
)

// Defines values for InvalidParameterMaximumLengthRule.
const (
	Max       InvalidParameterMaximumLengthRule = "max"
	MaxItems  InvalidParameterMaximumLengthRule = "max_items"
	MaxLength InvalidParameterMaximumLengthRule = "max_length"
)

// Defines values for InvalidParameterMinimumLengthRule.
const (
	Min          InvalidParameterMinimumLengthRule = "min"
	MinDigits    InvalidParameterMinimumLengthRule = "min_digits"
	MinItems     InvalidParameterMinimumLengthRule = "min_items"
	MinLength    InvalidParameterMinimumLengthRule = "min_length"
	MinLowercase InvalidParameterMinimumLengthRule = "min_lowercase"
	MinSymbols   InvalidParameterMinimumLengthRule = "min_symbols"
	MinUppercase InvalidParameterMinimumLengthRule = "min_uppercase"
)

// Defines values for InvalidRules.
const (
	Invalid                                InvalidRules = "invalid"
	IsArn                                  InvalidRules = "is_arn"
	IsArray                                InvalidRules = "is_array"
	IsBase64                               InvalidRules = "is_base64"
	IsBoolean                              InvalidRules = "is_boolean"
	IsDateTime                             InvalidRules = "is_date_time"
	IsFqdn                                 InvalidRules = "is_fqdn"
	IsInteger                              InvalidRules = "is_integer"
	IsLabel                                InvalidRules = "is_label"
	IsNull                                 InvalidRules = "is_null"
	IsNumber                               InvalidRules = "is_number"
	IsObject                               InvalidRules = "is_object"
	IsString                               InvalidRules = "is_string"
	IsSupportedNetworkAvailabilityZoneList InvalidRules = "is_supported_network_availability_zone_list"
	IsSupportedNetworkCidrBlock            InvalidRules = "is_supported_network_cidr_block"
	IsSupportedProviderRegion              InvalidRules = "is_supported_provider_region"
	IsUuid                                 InvalidRules = "is_uuid"
	MatchesRegex                           InvalidRules = "matches_regex"
	MissingReference                       InvalidRules = "missing_reference"
	Required                               InvalidRules = "required"
	UnknownProperty                        InvalidRules = "unknown_property"
)

// Defines values for PortalAuthStrategyClientCredentialsCredentialType.
const (
	PortalAuthStrategyClientCredentialsCredentialTypeClientCredentials            PortalAuthStrategyClientCredentialsCredentialType = "client_credentials"
	PortalAuthStrategyClientCredentialsCredentialTypeSelfManagedClientCredentials PortalAuthStrategyClientCredentialsCredentialType = "self_managed_client_credentials"
)

// Defines values for PortalAuthStrategyKeyAuthCredentialType.
const (
	PortalAuthStrategyKeyAuthCredentialTypeKeyAuth PortalAuthStrategyKeyAuthCredentialType = "key_auth"
)

// Defines values for PortalCustomizationThemeMode.
const (
	Dark   PortalCustomizationThemeMode = "dark"
	Light  PortalCustomizationThemeMode = "light"
	System PortalCustomizationThemeMode = "system"
)

// Defines values for PortalMenuItemVisibility.
const (
	PortalMenuItemVisibilityPrivate PortalMenuItemVisibility = "private"
	PortalMenuItemVisibilityPublic  PortalMenuItemVisibility = "public"
)

// Defines values for QueryApplicationAnalyticsDimensions.
const (
	QueryApplicationAnalyticsDimensionsApi               QueryApplicationAnalyticsDimensions = "api"
	QueryApplicationAnalyticsDimensionsApplication       QueryApplicationAnalyticsDimensions = "application"
	QueryApplicationAnalyticsDimensionsStatusCode        QueryApplicationAnalyticsDimensions = "status_code"
	QueryApplicationAnalyticsDimensionsStatusCodeGrouped QueryApplicationAnalyticsDimensions = "status_code_grouped"
	QueryApplicationAnalyticsDimensionsTime              QueryApplicationAnalyticsDimensions = "time"
)

// Defines values for QueryApplicationAnalyticsGranularity.
const (
	Daily          QueryApplicationAnalyticsGranularity = "daily"
	FiveMinutely   QueryApplicationAnalyticsGranularity = "fiveMinutely"
	Hourly         QueryApplicationAnalyticsGranularity = "hourly"
	Minutely       QueryApplicationAnalyticsGranularity = "minutely"
	TenMinutely    QueryApplicationAnalyticsGranularity = "tenMinutely"
	TenSecondly    QueryApplicationAnalyticsGranularity = "tenSecondly"
	ThirtyMinutely QueryApplicationAnalyticsGranularity = "thirtyMinutely"
	ThirtySecondly QueryApplicationAnalyticsGranularity = "thirtySecondly"
	Trend          QueryApplicationAnalyticsGranularity = "trend"
	TwelveHourly   QueryApplicationAnalyticsGranularity = "twelveHourly"
	TwoHourly      QueryApplicationAnalyticsGranularity = "twoHourly"
	Weekly         QueryApplicationAnalyticsGranularity = "weekly"
)

// Defines values for QueryApplicationAnalyticsMetrics.
const (
	QueryApplicationAnalyticsMetricsRequestCount           QueryApplicationAnalyticsMetrics = "request_count"
	QueryApplicationAnalyticsMetricsRequestPerMinute       QueryApplicationAnalyticsMetrics = "request_per_minute"
	QueryApplicationAnalyticsMetricsRequestSizeAverage     QueryApplicationAnalyticsMetrics = "request_size_average"
	QueryApplicationAnalyticsMetricsRequestSizeSum         QueryApplicationAnalyticsMetrics = "request_size_sum"
	QueryApplicationAnalyticsMetricsResponseLatencyAverage QueryApplicationAnalyticsMetrics = "response_latency_average"
	QueryApplicationAnalyticsMetricsResponseSizeAverage    QueryApplicationAnalyticsMetrics = "response_size_average"
	QueryApplicationAnalyticsMetricsResponseSizeSum        QueryApplicationAnalyticsMetrics = "response_size_sum"
)

// Defines values for QueryResponseMetaMetricNames.
const (
	QueryResponseMetaMetricNamesRequestCount           QueryResponseMetaMetricNames = "request_count"
	QueryResponseMetaMetricNamesRequestPerMinute       QueryResponseMetaMetricNames = "request_per_minute"
	QueryResponseMetaMetricNamesRequestSizeAverage     QueryResponseMetaMetricNames = "request_size_average"
	QueryResponseMetaMetricNamesRequestSizeSum         QueryResponseMetaMetricNames = "request_size_sum"
	QueryResponseMetaMetricNamesResponseLatencyAverage QueryResponseMetaMetricNames = "response_latency_average"
	QueryResponseMetaMetricNamesResponseSizeAverage    QueryResponseMetaMetricNames = "response_size_average"
	QueryResponseMetaMetricNamesResponseSizeSum        QueryResponseMetaMetricNames = "response_size_sum"
)

// Defines values for RelativeTimeRangeDtoTimeRange.
const (
	CurrentMonth  RelativeTimeRangeDtoTimeRange = "current_month"
	CurrentWeek   RelativeTimeRangeDtoTimeRange = "current_week"
	N12h          RelativeTimeRangeDtoTimeRange = "12h"
	N15m          RelativeTimeRangeDtoTimeRange = "15m"
	N1h           RelativeTimeRangeDtoTimeRange = "1h"
	N24h          RelativeTimeRangeDtoTimeRange = "24h"
	N30d          RelativeTimeRangeDtoTimeRange = "30d"
	N6h           RelativeTimeRangeDtoTimeRange = "6h"
	N7d           RelativeTimeRangeDtoTimeRange = "7d"
	PreviousMonth RelativeTimeRangeDtoTimeRange = "previous_month"
	PreviousWeek  RelativeTimeRangeDtoTimeRange = "previous_week"
)

// Defines values for RelativeTimeRangeDtoType.
const (
	Relative RelativeTimeRangeDtoType = "relative"
)

// Defines values for StatusCodeFilterField.
const (
	StatusCode StatusCodeFilterField = "status_code"
)

// Defines values for StatusCodeGroupedFilterField.
const (
	StatusCodeGrouped StatusCodeGroupedFilterField = "status_code_grouped"
)

// Defines values for Visibility.
const (
	VisibilityPrivate Visibility = "private"
	VisibilityPublic  Visibility = "public"
)

// Defines values for FilterByCredentialTypeEquality.
const (
	FilterByCredentialTypeEqualityClientCredentials            FilterByCredentialTypeEquality = "client_credentials"
	FilterByCredentialTypeEqualityKeyAuth                      FilterByCredentialTypeEquality = "key_auth"
	FilterByCredentialTypeEqualitySelfManagedClientCredentials FilterByCredentialTypeEquality = "self_managed_client_credentials"
)

// Defines values for FilterByStatusEquality.
const (
	FilterByStatusEqualityApproved FilterByStatusEquality = "approved"
	FilterByStatusEqualityPending  FilterByStatusEquality = "pending"
	FilterByStatusEqualityRejected FilterByStatusEquality = "rejected"
	FilterByStatusEqualityRevoked  FilterByStatusEquality = "revoked"
)

// Defines values for FilterByStatusEqualityShort.
const (
	FilterByStatusEqualityShortApproved FilterByStatusEqualityShort = "approved"
	FilterByStatusEqualityShortPending  FilterByStatusEqualityShort = "pending"
	FilterByStatusEqualityShortRejected FilterByStatusEqualityShort = "rejected"
	FilterByStatusEqualityShortRevoked  FilterByStatusEqualityShort = "revoked"
)

// Defines values for FilterByVisibilityEquality.
const (
	FilterByVisibilityEqualityPrivate FilterByVisibilityEquality = "private"
	FilterByVisibilityEqualityPublic  FilterByVisibilityEquality = "public"
)

// Defines values for FilterByVisibilityEqualityShort.
const (
	FilterByVisibilityEqualityShortPrivate FilterByVisibilityEqualityShort = "private"
	FilterByVisibilityEqualityShortPublic  FilterByVisibilityEqualityShort = "public"
)

// Defines values for ListApplicationAuthStrategiesParamsFilterCredentialTypeEq.
const (
	ListApplicationAuthStrategiesParamsFilterCredentialTypeEqClientCredentials            ListApplicationAuthStrategiesParamsFilterCredentialTypeEq = "client_credentials"
	ListApplicationAuthStrategiesParamsFilterCredentialTypeEqKeyAuth                      ListApplicationAuthStrategiesParamsFilterCredentialTypeEq = "key_auth"
	ListApplicationAuthStrategiesParamsFilterCredentialTypeEqSelfManagedClientCredentials ListApplicationAuthStrategiesParamsFilterCredentialTypeEq = "self_managed_client_credentials"
)

// Defines values for ListApplicationRegistrationsParamsFilterStatusEq.
const (
	ListApplicationRegistrationsParamsFilterStatusEqApproved ListApplicationRegistrationsParamsFilterStatusEq = "approved"
	ListApplicationRegistrationsParamsFilterStatusEqPending  ListApplicationRegistrationsParamsFilterStatusEq = "pending"
	ListApplicationRegistrationsParamsFilterStatusEqRejected ListApplicationRegistrationsParamsFilterStatusEq = "rejected"
	ListApplicationRegistrationsParamsFilterStatusEqRevoked  ListApplicationRegistrationsParamsFilterStatusEq = "revoked"
)

// Defines values for ListApplicationRegistrationsParamsFilterStatus.
const (
	ListApplicationRegistrationsParamsFilterStatusApproved ListApplicationRegistrationsParamsFilterStatus = "approved"
	ListApplicationRegistrationsParamsFilterStatusPending  ListApplicationRegistrationsParamsFilterStatus = "pending"
	ListApplicationRegistrationsParamsFilterStatusRejected ListApplicationRegistrationsParamsFilterStatus = "rejected"
	ListApplicationRegistrationsParamsFilterStatusRevoked  ListApplicationRegistrationsParamsFilterStatus = "revoked"
)

// Defines values for ListPortalPagesParamsFilterVisibilityEq.
const (
	ListPortalPagesParamsFilterVisibilityEqPrivate ListPortalPagesParamsFilterVisibilityEq = "private"
	ListPortalPagesParamsFilterVisibilityEqPublic  ListPortalPagesParamsFilterVisibilityEq = "public"
)

// Defines values for ListPortalPagesParamsFilterVisibility.
const (
	ListPortalPagesParamsFilterVisibilityPrivate ListPortalPagesParamsFilterVisibility = "private"
	ListPortalPagesParamsFilterVisibilityPublic  ListPortalPagesParamsFilterVisibility = "public"
)

// Defines values for ListPortalSnippetsParamsFilterVisibilityEq.
const (
	ListPortalSnippetsParamsFilterVisibilityEqPrivate ListPortalSnippetsParamsFilterVisibilityEq = "private"
	ListPortalSnippetsParamsFilterVisibilityEqPublic  ListPortalSnippetsParamsFilterVisibilityEq = "public"
)

// Defines values for ListPortalSnippetsParamsFilterVisibility.
const (
	Private ListPortalSnippetsParamsFilterVisibility = "private"
	Public  ListPortalSnippetsParamsFilterVisibility = "public"
)

// AbsoluteTimeRangeDto A duration representing an exact start and end time.
type AbsoluteTimeRangeDto struct {
	End   time.Time                `json:"end"`
	Start time.Time                `json:"start"`
	Type  AbsoluteTimeRangeDtoType `json:"type"`
	Tz    *string                  `json:"tz,omitempty"`
}

// AbsoluteTimeRangeDtoType defines model for AbsoluteTimeRangeDto.Type.
type AbsoluteTimeRangeDtoType string

// Api defines model for Api.
type Api struct {
	// Attributes A set of attributes that describe the API
	Attributes map[string][]string `json:"attributes"`

	// AuthStrategies Configurations for how the API is able to be registered for by applications.
	AuthStrategies *[]AuthStrategy `json:"auth_strategies,omitempty"`

	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt *CreatedAt `json:"created_at,omitempty"`

	// CurrentVersionSummary Summary of the current version (version string of api.version matches version)
	CurrentVersionSummary *struct {
		// Id The API version identifier.
		Id   *openapi_types.UUID `json:"id,omitempty"`
		Spec struct {
			// Type The type of specification being stored. This allows us to render the specification correctly.
			Type ApiSpecType `json:"type"`
		} `json:"spec"`
	} `json:"current_version_summary"`
	Description *string `json:"description"`

	// Id Contains a unique identifier used for this resource.
	Id *UUID `json:"id,omitempty"`

	// Name Name of API.
	Name string `json:"name"`

	// Slug The API `slug` is used in generated URLs to provide human readable paths.
	//
	// Defaults to `slugify(name + version)`
	Slug string `json:"slug"`

	// Specifications Returns a list of specifications for an API.
	// **Note:** This Beta property is deprecated and will be removed in a GA release.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Specifications []struct {
		// Id The API specification identifier.
		Id *openapi_types.UUID `json:"id,omitempty"`

		// Type The type of specification being stored. This allows us to render the specification correctly.
		Type ApiSpecType `json:"type"`
	} `json:"specifications"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`

	// Version Version of API.
	Version *string `json:"version"`

	// Visibility Visibility of the API listing.
	// Public APIs are visible to anyone and do not require authentication to view and retrieve information about them.
	// Private APIs are only visible to authenticated developers who have been granted access.
	Visibility ApiVisibility `json:"visibility"`
}

// ApiVisibility Visibility of the API listing.
// Public APIs are visible to anyone and do not require authentication to view and retrieve information about them.
// Private APIs are only visible to authenticated developers who have been granted access.
type ApiVisibility string

// ApiActionsResponse defines model for ApiActionsResponse.
type ApiActionsResponse struct {
	// Actions List of actions that can be performed on the API
	Actions struct {
		Register          bool `json:"register"`
		View              bool `json:"view"`
		ViewDocumentation bool `json:"view_documentation"`
	} `json:"actions"`
}

// ApiApplication defines model for ApiApplication.
type ApiApplication struct {
	AuthStrategy *AuthStrategy `json:"auth_strategy,omitempty"`

	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt *CreatedAt `json:"created_at,omitempty"`

	// Id Contains a unique identifier used for this resource.
	Id *UUID `json:"id,omitempty"`

	// Name The name of the application
	Name string `json:"name"`

	// RegistrationId Contains a unique identifier for a resource.
	RegistrationId     *NullableUUID                     `json:"registration_id"`
	RegistrationStatus *ApiApplicationRegistrationStatus `json:"registration_status"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`
}

// ApiApplicationRegistrationStatus defines model for ApiApplication.RegistrationStatus.
type ApiApplicationRegistrationStatus string

// ApiAttributeFilterParameters defines model for ApiAttributeFilterParameters.
type ApiAttributeFilterParameters struct {
	// Key Filters on the given string field value by either exact or fuzzy match.
	Key *StringFieldFilter `json:"key,omitempty"`
}

// ApiAttributeItem defines model for ApiAttributeItem.
type ApiAttributeItem struct {
	Key    string `json:"key"`
	Values []struct {
		ApiCount float32 `json:"api_count"`

		// SelectedApiCount The number of APIs that match this attribute value when considering the selected filters.
		// Only present when the 'selected' query parameter is provided.
		SelectedApiCount *float32 `json:"selected_api_count,omitempty"`
		Value            string   `json:"value"`
	} `json:"values"`
}

// ApiDocument A document for an API. This is a document that is not a part of the API specification.
type ApiDocument struct {
	// Content Markdown document
	Content string `json:"content"`

	// Id Unique identifier of the document.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// ParentDocumentId Unique identifier of the parent document.
	ParentDocumentId *openapi_types.UUID `json:"parent_document_id"`

	// Slug Slug of the document. This is used in the URL to identify the document.
	Slug string `json:"slug"`

	// Title Title of the document.
	Title string `json:"title"`
}

// ApiDocumentTree a document tree
type ApiDocumentTree struct {
	Children []ApiDocumentTree `json:"children"`

	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt        *CreatedAt          `json:"created_at,omitempty"`
	Id               openapi_types.UUID  `json:"id"`
	ParentDocumentId *openapi_types.UUID `json:"parent_document_id"`

	// Slug the slug of the document
	Slug string `json:"slug"`

	// Title the title of the document
	Title string `json:"title"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`
}

// ApiFilter defines model for ApiFilter.
type ApiFilter struct {
	// Field The dimension to filter.
	Field ApiFilterField `json:"field"`

	// Operator The type of filter to apply.  `in` filters will limit results to only the specified values, while `not_in` filters will exclude the specified values.
	Operator FilterType `json:"operator"`

	// Value The UUIDs of the API product versions to include in the results.
	Value []string `json:"value"`
}

// ApiFilterField The dimension to filter.
type ApiFilterField string

// ApiFilterParameters defines model for ApiFilterParameters.
type ApiFilterParameters struct {
	Attributes *AttributesFieldFilter `json:"attributes,omitempty"`

	// CreatedAt Filters on the given datetime (RFC-3339) field value.
	CreatedAt *DateTimeFieldFilter `json:"created_at,omitempty"`

	// Description Filters on the given string field value by either exact or fuzzy match.
	Description *StringFieldFilter `json:"description,omitempty"`

	// Id Filters on the given UUID field value by exact match.
	Id *UuidFieldFilter `json:"id,omitempty"`

	// Name Filters on the given string field value by either exact or fuzzy match.
	Name *StringFieldFilter `json:"name,omitempty"`

	// UpdatedAt Filters on the given datetime (RFC-3339) field value.
	UpdatedAt *DateTimeFieldFilter `json:"updated_at,omitempty"`

	// Version Filters on the given string field value by either exact or fuzzy match.
	Version *StringFieldFilter `json:"version,omitempty"`
}

// ApiId The API identifier.
type ApiId = openapi_types.UUID

// ApiListApplicationsPage defines model for ApiListApplicationsPage.
type ApiListApplicationsPage struct {
	Data []ApiApplication `json:"data"`

	// Meta returns the pagination information
	Meta PaginatedMeta `json:"meta"`
}

// ApiListPage defines model for ApiListPage.
type ApiListPage struct {
	Data []Api `json:"data"`

	// Meta returns the pagination information
	Meta PaginatedMeta `json:"meta"`
}

// ApiSlug The Api `slug` is used in generated URLs to provide human readable paths.
//
// Defaults to `slugify(name + version)`
type ApiSlug = string

// ApiSpecDocument API specification document.
type ApiSpecDocument struct {
	// ApiType The type of specification being stored. This allows us to render the specification correctly.
	ApiType ApiSpecType `json:"api_type"`
	Content string      `json:"content"`
}

// ApiSpecDocumentSummary Info about an API specification document.
type ApiSpecDocumentSummary struct {
	// ApiType The type of specification being stored. This allows us to render the specification correctly.
	ApiType ApiSpecType `json:"api_type"`

	// Id Contains a unique identifier used for this resource.
	Id *UUID `json:"id,omitempty"`
}

// ApiSpecType The type of specification being stored. This allows us to render the specification correctly.
type ApiSpecType string

// ApiVersion Singular version of an API
type ApiVersion struct {
	// Id Contains a unique identifier used for this resource.
	Id   *UUID `json:"id,omitempty"`
	Spec struct {
		// Content The JSON string or YAML content of the API specification.
		Content *string `json:"content,omitempty"`

		// Type The type of specification being stored. This allows us to render the specification correctly.
		Type ApiSpecType `json:"type"`
	} `json:"spec"`

	// Version The version string of the API version .
	Version string `json:"version"`
}

// ApiVersionSummary Summary of an API version.
type ApiVersionSummary struct {
	// Id Contains a unique identifier used for this resource.
	Id   *UUID `json:"id,omitempty"`
	Spec struct {
		// Type The type of specification being stored. This allows us to render the specification correctly.
		Type ApiSpecType `json:"type"`
	} `json:"spec"`

	// Version The version string of the API version .
	Version string `json:"version"`
}

// ApplicationClientId A unique value used to identify the portal application when authenticating with a Client Secret.
type ApplicationClientId = string

// ApplicationClientSecret The client secret used to authenticate with registered APIs.
type ApplicationClientSecret = string

// ApplicationCreationResponse Application creation response payload
type ApplicationCreationResponse struct {
	AuthStrategy PortalAuthStrategy `json:"auth_strategy"`

	// ClientId A unique value used to identify the portal application when authenticating with a Client Secret.
	ClientId *ApplicationClientId `json:"client_id,omitempty"`

	// ClientSecret The client secret used to authenticate with registered APIs.
	ClientSecret *ApplicationClientSecret `json:"client_secret,omitempty"`

	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt   *CreatedAt `json:"created_at,omitempty"`
	Description *string    `json:"description"`

	// Id Contains a unique identifier used for this resource.
	Id          *UUID   `json:"id,omitempty"`
	Name        string  `json:"name"`
	RedirectUri *string `json:"redirect_uri"`

	// Scopes The granted scopes for the application. Will only be included if supported by the application's auth strategy.
	Scopes *Scopes `json:"scopes,omitempty"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`
}

// ApplicationFilter defines model for ApplicationFilter.
type ApplicationFilter struct {
	// Field The dimension to filter. If no application filter is provided the API will implicitly filter on the applications owned by the developer making the query request.
	Field ApplicationFilterField `json:"field"`

	// Operator The type of filter to apply.  `in` filters will limit results to only the specified values, while `not_in` filters will exclude the specified values.
	Operator FilterType `json:"operator"`

	// Value The UUIDs of the dev portal applications to include in the results.
	Value []string `json:"value"`
}

// ApplicationFilterField The dimension to filter. If no application filter is provided the API will implicitly filter on the applications owned by the developer making the query request.
type ApplicationFilterField string

// ApplicationFilterParameter defines model for ApplicationFilterParameter.
type ApplicationFilterParameter struct {
	// Name Filters on the given string field value by either exact or fuzzy match.
	Name *StringFieldFilter `json:"name,omitempty"`
}

// ApplicationUpdateResponse Application update response payload
type ApplicationUpdateResponse struct {
	AuthStrategy *PortalAuthStrategy `json:"auth_strategy,omitempty"`

	// ClientId A unique value used to identify the portal application when authenticating with a Client Secret.
	ClientId *ApplicationClientId `json:"client_id,omitempty"`

	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt   *CreatedAt `json:"created_at,omitempty"`
	Description *string    `json:"description"`

	// Id Contains a unique identifier used for this resource.
	Id          *UUID   `json:"id,omitempty"`
	Name        string  `json:"name"`
	RedirectUri *string `json:"redirect_uri"`

	// Scopes The granted scopes for the application. Will only be included if supported by the application's auth strategy.
	Scopes *Scopes `json:"scopes,omitempty"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`
}

// AttributesFieldFilter defines model for AttributesFieldFilter.
type AttributesFieldFilter struct {
	union json.RawMessage
}

// AuthMethods defines model for AuthMethods.
type AuthMethods = []string

// AuthStrategy defines model for AuthStrategy.
type AuthStrategy struct {
	union json.RawMessage
}

// AuthStrategyClientCredentials Client Credential Auth strategy that the application uses.
type AuthStrategyClientCredentials struct {
	AuthMethods AuthMethods `json:"auth_methods"`

	// AvailableScopes Possible developer selectable scopes for an application. Only present when using DCR Provider that supports it.
	AvailableScopes *AvailableScopes                            `json:"available_scopes,omitempty"`
	CredentialType  AuthStrategyClientCredentialsCredentialType `json:"credential_type"`

	// Id The Application Auth Strategy ID.
	Id   *openapi_types.UUID `json:"id,omitempty"`
	Name string              `json:"name"`
}

// AuthStrategyClientCredentialsCredentialType defines model for AuthStrategyClientCredentials.CredentialType.
type AuthStrategyClientCredentialsCredentialType string

// AuthStrategyId ID of the auth strategy to use for the application. If null or not included, the default application auth strategy will be used.
type AuthStrategyId = openapi_types.UUID

// AuthStrategyKeyAuth KeyAuth Auth strategy that the application uses.
type AuthStrategyKeyAuth struct {
	CredentialType AuthStrategyKeyAuthCredentialType `json:"credential_type"`

	// Id The Application Auth Strategy ID.
	Id       *openapi_types.UUID `json:"id,omitempty"`
	KeyNames []string            `json:"key_names"`
	Name     string              `json:"name"`
}

// AuthStrategyKeyAuthCredentialType defines model for AuthStrategyKeyAuth.CredentialType.
type AuthStrategyKeyAuthCredentialType string

// AuthenticateRequest The request schema for the authenticate endpoint.
type AuthenticateRequest struct {
	Password *string              `json:"password,omitempty"`
	Username *openapi_types.Email `json:"username,omitempty"`
}

// AvailableScopes Possible developer selectable scopes for an application. Only present when using DCR Provider that supports it.
type AvailableScopes = []string

// BadRequestError defines model for BadRequestError.
type BadRequestError struct {
	// Detail A human readable explanation specific to this occurence of the problem.
	// This field may contain request/entity data to help the user understand
	// what went wrong. Enclose variable values in square brackets. Should be
	// provided as "Sentence case" for direct use in the UI.
	Detail *string `json:"detail,omitempty"`

	// Instance Used to return the correlation ID back to the user, in the format
	// kong:trace:<correlation_id>. This helps us find the relevant logs
	// when a customer reports an issue.
	Instance *string `json:"instance,omitempty"`

	// InvalidParameters invalid parameters
	InvalidParameters InvalidParameters `json:"invalid_parameters"`

	// Status The HTTP status code of the error. Useful when passing the response
	// body to child properties in a frontend UI. Must be returned as an integer.
	Status *int `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem. It should not
	// change between occurences of a problem, except for localization.
	// Should be provided as "Sentence case" for direct use in the UI.
	Title *string `json:"title,omitempty"`

	// Type The error type.
	Type *string `json:"type,omitempty"`
}

// BaseError standard error
type BaseError struct {
	// Detail A human readable explanation specific to this occurence of the problem.
	// This field may contain request/entity data to help the user understand
	// what went wrong. Enclose variable values in square brackets. Should be
	// provided as "Sentence case" for direct use in the UI.
	Detail *string `json:"detail,omitempty"`

	// Instance Used to return the correlation ID back to the user, in the format
	// kong:trace:<correlation_id>. This helps us find the relevant logs
	// when a customer reports an issue.
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code of the error. Useful when passing the response
	// body to child properties in a frontend UI. Must be returned as an integer.
	Status *int `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem. It should not
	// change between occurences of a problem, except for localization.
	// Should be provided as "Sentence case" for direct use in the UI.
	Title *string `json:"title,omitempty"`

	// Type The error type.
	Type *string `json:"type,omitempty"`
}

// ConflictError defines model for ConflictError.
type ConflictError struct {
	Detail   interface{} `json:"detail"`
	Instance interface{} `json:"instance"`
	Status   interface{} `json:"status"`
	Title    interface{} `json:"title"`
	Type     interface{} `json:"type,omitempty"`
}

// CreateApiRegistrationPayload The payload to create a registration.
type CreateApiRegistrationPayload struct {
	// ApiId The API id required for registration.
	ApiId openapi_types.UUID `json:"api_id"`
}

// CreateApplicationPayload Application creation payload
type CreateApplicationPayload struct {
	// AuthStrategyId ID of the auth strategy to use for the application. If null or not included, the default application auth strategy will be used.
	AuthStrategyId *AuthStrategyId `json:"auth_strategy_id"`

	// ClientId A unique value used to identify the portal application when authenticating with a Client Secret.
	ClientId *ApplicationClientId `json:"client_id,omitempty"`

	// Description A brief description of the application
	Description *string `json:"description,omitempty"`

	// Name The name of the application
	Name string `json:"name"`

	// RedirectUri URL to redirect to after completing an OIDC auth flow
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// Scopes The granted scopes for the application. Will only be included if supported by the application's auth strategy.
	Scopes *Scopes `json:"scopes,omitempty"`
}

// CreateCredentialRequest defines model for CreateCredentialRequest.
type CreateCredentialRequest struct {
	DisplayName *string `json:"display_name,omitempty"`
}

// CreatedAt An ISO-8601 timestamp representation of entity creation date.
type CreatedAt = time.Time

// CredentialCreationResponse defines model for CredentialCreationResponse.
type CredentialCreationResponse struct {
	Credential  string `json:"credential"`
	DisplayName string `json:"display_name"`

	// Id Contains a unique identifier used for this resource.
	Id *UUID `json:"id,omitempty"`
}

// CursorMeta Pagination metadata.
type CursorMeta struct {
	Page CursorMetaPage `json:"page"`
}

// CursorMetaPage defines model for CursorMetaPage.
type CursorMetaPage struct {
	// First URI to the first page
	First *string `json:"first,omitempty"`

	// Last URI to the last page
	Last *string `json:"last,omitempty"`

	// Next URI to the next page
	Next *string `json:"next"`

	// Previous URI to the previous page
	Previous *string `json:"previous"`

	// Size Requested page size
	Size float32 `json:"size"`
}

// DateTimeFieldFilter Filters on the given datetime (RFC-3339) field value.
type DateTimeFieldFilter struct {
	union json.RawMessage
}

// DateTimeFieldFilter0 Value strictly equals given RFC-3339 formatted timestamp in UTC
type DateTimeFieldFilter0 = time.Time

// DateTimeFieldFilter1 defines model for .
type DateTimeFieldFilter1 struct {
	// Eq Value strictly equals given RFC-3339 formatted timestamp in UTC
	Eq time.Time `json:"eq"`
}

// DateTimeFieldFilter2 defines model for .
type DateTimeFieldFilter2 struct {
	// Lt Value is less than the given RFC-3339 formatted timestamp in UTC
	Lt time.Time `json:"lt"`
}

// DateTimeFieldFilter3 defines model for .
type DateTimeFieldFilter3 struct {
	// Lte Value is less than or equal to the given RFC-3339 formatted timestamp in UTC
	Lte time.Time `json:"lte"`
}

// DateTimeFieldFilter4 defines model for .
type DateTimeFieldFilter4 struct {
	// Lt Value is greater than the given RFC-3339 formatted timestamp in UTC
	Lt *time.Time `json:"lt,omitempty"`
}

// DateTimeFieldFilter5 defines model for .
type DateTimeFieldFilter5 struct {
	// Lte Value is greater than or equal to the given RFC-3339 formatted timestamp in UTC
	Lte *time.Time `json:"lte,omitempty"`
}

// Description defines model for Description.
type Description = string

// Developer A user who can use a developer portal
type Developer struct {
	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt *CreatedAt          `json:"created_at,omitempty"`
	Email     openapi_types.Email `json:"email"`
	FullName  string              `json:"full_name"`

	// Id Contains a unique identifier used for this resource.
	Id *UUID `json:"id,omitempty"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`
}

// DisplayBlob defines model for DisplayBlob.
type DisplayBlob struct {
	Api               *map[string]DisplayEntry `json:"api,omitempty"`
	Application       *map[string]DisplayEntry `json:"application,omitempty"`
	StatusCode        *map[string]DisplayEntry `json:"status_code,omitempty"`
	StatusCodeGrouped *map[string]DisplayEntry `json:"status_code_grouped,omitempty"`
}

// DisplayEntry defines model for DisplayEntry.
type DisplayEntry struct {
	Deleted      *bool  `json:"deleted,omitempty"`
	IsOtherGroup *bool  `json:"is_other_group,omitempty"`
	Name         string `json:"name"`
}

// DocumentFormatContentTypeEnum defines model for DocumentFormatContentTypeEnum.
type DocumentFormatContentTypeEnum string

// DocumentId defines model for DocumentId.
type DocumentId = openapi_types.UUID

// DocumentSlug Slug of the document. This is used in the URL to identify the document.
type DocumentSlug = string

// FilterType The type of filter to apply.  `in` filters will limit results to only the specified values, while `not_in` filters will exclude the specified values.
type FilterType string

// ForbiddenError defines model for ForbiddenError.
type ForbiddenError struct {
	Detail   interface{} `json:"detail"`
	Instance interface{} `json:"instance"`
	Status   interface{} `json:"status"`
	Title    interface{} `json:"title"`
	Type     interface{} `json:"type,omitempty"`
}

// GetApiRegistrationResponse defines model for GetApiRegistrationResponse.
type GetApiRegistrationResponse struct {
	// ApiId Contains a unique identifier used by the Portal API for this resource.
	ApiId openapi_types.UUID `json:"api_id"`

	// ApiName The name of the API. This is the name that is displayed in the developer portal.
	ApiName string `json:"api_name"`

	// ApiSlug The API `slug` is used in generated URLs to provide human readable paths.
	//
	// Defaults to `slugify(name + version)`
	ApiSlug string `json:"api_slug"`

	// ApplicationId Contains a unique identifier used by the Portal API for this resource.
	ApplicationId openapi_types.UUID `json:"application_id"`

	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt *CreatedAt `json:"created_at,omitempty"`

	// Id Contains a unique identifier used for this resource.
	Id *UUID `json:"id,omitempty"`

	// Status The approval status of the registration.
	Status GetApiRegistrationResponseStatus `json:"status"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`
}

// GetApiRegistrationResponseStatus The approval status of the registration.
type GetApiRegistrationResponseStatus string

// GetApplicationResponse defines model for GetApplicationResponse.
type GetApplicationResponse struct {
	AuthStrategy *PortalAuthStrategy `json:"auth_strategy,omitempty"`

	// ClientId A unique value used to identify the portal application when authenticating with a Client Secret.
	ClientId *ApplicationClientId `json:"client_id,omitempty"`

	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt   *CreatedAt `json:"created_at,omitempty"`
	Description *string    `json:"description"`

	// Id Contains a unique identifier used for this resource.
	Id          *UUID   `json:"id,omitempty"`
	Name        string  `json:"name"`
	RedirectUri *string `json:"redirect_uri"`

	// Scopes The granted scopes for the application. Will only be included if supported by the application's auth strategy.
	Scopes *Scopes `json:"scopes,omitempty"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`
}

// GetConfigResponse defines model for GetConfigResponse.
type GetConfigResponse struct {
	// Analytics Null if analytics is not enabled.
	Analytics *struct {
		// Percentiles True if analytics percentiles are enabled.
		Percentiles bool `json:"percentiles"`

		// RetentionMs Analytics retention in milliseconds.
		RetentionMs int `json:"retention_ms"`
	} `json:"analytics"`
}

// GetGrantedScopesAPIResponse defines model for GetGrantedScopesAPIResponse.
type GetGrantedScopesAPIResponse struct {
	// Scopes List of granted scopes, directly updated from the IDP
	Scopes RefreshedGrantedScopes `json:"scopes"`
}

// GoneError defines model for GoneError.
type GoneError struct {
	Detail   interface{} `json:"detail"`
	Instance interface{} `json:"instance"`
	Status   interface{} `json:"status"`
	Title    interface{} `json:"title"`
	Type     interface{} `json:"type,omitempty"`
}

// InvalidParameterChoiceItem defines model for InvalidParameterChoiceItem.
type InvalidParameterChoiceItem struct {
	Choices *[]interface{} `json:"choices,omitempty"`
	Field   *string        `json:"field,omitempty"`
	Reason  *string        `json:"reason,omitempty"`

	// Rule invalid parameters rules
	Rule   *InvalidParameterChoiceItemRule `json:"rule,omitempty"`
	Source *string                         `json:"source,omitempty"`
}

// InvalidParameterChoiceItemRule invalid parameters rules
type InvalidParameterChoiceItemRule string

// InvalidParameterDependentItem defines model for InvalidParameterDependentItem.
type InvalidParameterDependentItem struct {
	Dependents *[]interface{} `json:"dependents"`
	Field      *string        `json:"field,omitempty"`
	Reason     *string        `json:"reason,omitempty"`

	// Rule invalid parameters rules
	Rule   *InvalidParameterDependentItemRule `json:"rule"`
	Source *string                            `json:"source,omitempty"`
}

// InvalidParameterDependentItemRule invalid parameters rules
type InvalidParameterDependentItemRule string

// InvalidParameterMaximumLength defines model for InvalidParameterMaximumLength.
type InvalidParameterMaximumLength struct {
	Field   *string `json:"field,omitempty"`
	Maximum int     `json:"maximum"`
	Reason  *string `json:"reason,omitempty"`

	// Rule invalid parameters rules
	Rule   *InvalidParameterMaximumLengthRule `json:"rule,omitempty"`
	Source *string                            `json:"source,omitempty"`
}

// InvalidParameterMaximumLengthRule invalid parameters rules
type InvalidParameterMaximumLengthRule string

// InvalidParameterMinimumLength defines model for InvalidParameterMinimumLength.
type InvalidParameterMinimumLength struct {
	Field   *string `json:"field,omitempty"`
	Minimum int     `json:"minimum"`
	Reason  *string `json:"reason,omitempty"`

	// Rule invalid parameters rules
	Rule   *InvalidParameterMinimumLengthRule `json:"rule,omitempty"`
	Source *string                            `json:"source,omitempty"`
}

// InvalidParameterMinimumLengthRule invalid parameters rules
type InvalidParameterMinimumLengthRule string

// InvalidParameterStandard defines model for InvalidParameterStandard.
type InvalidParameterStandard struct {
	Field  *string `json:"field,omitempty"`
	Reason *string `json:"reason,omitempty"`

	// Rule invalid parameters rules
	Rule   *InvalidRules `json:"rule"`
	Source *string       `json:"source,omitempty"`
}

// InvalidParameters invalid parameters
type InvalidParameters = []InvalidParameters_Item

// InvalidParameters_Item defines model for InvalidParameters.Item.
type InvalidParameters_Item struct {
	union json.RawMessage
}

// InvalidRules invalid parameters rules
type InvalidRules string

// ListApiAttributesPage defines model for ListApiAttributesPage.
type ListApiAttributesPage struct {
	Data []ApiAttributeItem `json:"data"`

	// Meta returns the pagination information
	Meta PaginatedMeta `json:"meta"`
}

// ListApiRegistrationsResponse defines model for ListApiRegistrationsResponse.
type ListApiRegistrationsResponse struct {
	Data []GetApiRegistrationResponse `json:"data"`

	// Meta returns the pagination information
	Meta PaginatedMeta `json:"meta"`
}

// ListApplicationsResponse defines model for ListApplicationsResponse.
type ListApplicationsResponse struct {
	Data []GetApplicationResponse `json:"data"`

	// Meta returns the pagination information
	Meta PaginatedMeta `json:"meta"`
}

// ListAuthStrategiesResponse defines model for ListAuthStrategiesResponse.
type ListAuthStrategiesResponse struct {
	Data []PortalAuthStrategy `json:"data"`

	// Meta returns the pagination information
	Meta PaginatedMeta `json:"meta"`
}

// ListCredentialsResponse defines model for ListCredentialsResponse.
type ListCredentialsResponse struct {
	Data []struct {
		DisplayName string `json:"display_name"`

		// Id Contains a unique identifier used for this resource.
		Id *UUID `json:"id,omitempty"`
	} `json:"data"`

	// Meta returns the pagination information
	Meta PaginatedMeta `json:"meta"`
}

// ListPortalPages A paginated list of pages for the portal
type ListPortalPages struct {
	Data *[]PortalPageInfo `json:"data,omitempty"`
}

// ListPortalSnippets A paginated list of snippets for the portal
type ListPortalSnippets struct {
	Data *[]PortalSnippetInfo `json:"data,omitempty"`

	// Meta returns the pagination information
	Meta *PaginatedMeta `json:"meta,omitempty"`
}

// NotFoundError defines model for NotFoundError.
type NotFoundError struct {
	Detail   interface{} `json:"detail"`
	Instance interface{} `json:"instance"`
	Status   interface{} `json:"status"`
	Title    interface{} `json:"title"`
	Type     interface{} `json:"type,omitempty"`
}

// NullableUUID Contains a unique identifier for a resource.
type NullableUUID = openapi_types.UUID

// PageContent The renderable markdown content of the page
type PageContent = string

// PageId The unique identifier of the page
type PageId = openapi_types.UUID

// PageMeta Contains pagination query parameters and the total number of objects returned.
type PageMeta struct {
	Number float32 `json:"number"`
	Size   float32 `json:"size"`
	Total  float32 `json:"total"`
}

// PageSlug The slug of the page.
type PageSlug = string

// PageTitle The title of the page
type PageTitle = string

// PaginatedMeta returns the pagination information
type PaginatedMeta struct {
	// Page Contains pagination query parameters and the total number of objects returned.
	Page PageMeta `json:"page"`
}

// ParentPageId Pages may be rendered as a tree of files.
type ParentPageId = openapi_types.UUID

// PortalAuthStrategy defines model for PortalAuthStrategy.
type PortalAuthStrategy struct {
	union json.RawMessage
}

// PortalAuthStrategyClientCredentials Client Credential Auth strategy that the application uses.
type PortalAuthStrategyClientCredentials struct {
	AuthMethods AuthMethods `json:"auth_methods"`

	// AvailableScopes Possible developer selectable scopes for an application. Only present when using DCR Provider that supports it.
	AvailableScopes *AvailableScopes                                  `json:"available_scopes,omitempty"`
	CredentialType  PortalAuthStrategyClientCredentialsCredentialType `json:"credential_type"`

	// Id The Application Auth Strategy ID.
	Id   *openapi_types.UUID `json:"id,omitempty"`
	Name string              `json:"name"`
}

// PortalAuthStrategyClientCredentialsCredentialType defines model for PortalAuthStrategyClientCredentials.CredentialType.
type PortalAuthStrategyClientCredentialsCredentialType string

// PortalAuthStrategyKeyAuth KeyAuth Auth strategy that the application uses.
type PortalAuthStrategyKeyAuth struct {
	CredentialType PortalAuthStrategyKeyAuthCredentialType `json:"credential_type"`

	// Id The Application Auth Strategy ID.
	Id       *openapi_types.UUID `json:"id,omitempty"`
	KeyNames []string            `json:"key_names"`
	Name     string              `json:"name"`
}

// PortalAuthStrategyKeyAuthCredentialType defines model for PortalAuthStrategyKeyAuth.CredentialType.
type PortalAuthStrategyKeyAuthCredentialType string

// PortalContext Describes the portal execution context
type PortalContext struct {
	// AuthenticationEnabled Whether authentication is enabled for the portal
	AuthenticationEnabled bool `json:"authentication_enabled"`

	// BasicAuthEnabled Whether the portal can be accessed via email and password
	BasicAuthEnabled bool `json:"basic_auth_enabled"`

	// CanonicalDomain The canonical domain of the developer portal
	CanonicalDomain string `json:"canonical_domain"`

	// Name Name of the developer portal
	Name string `json:"name"`

	// OidcAuthEnabled Whether the portal can be accessed via authentication with Single Sign On (SSO) through OpenID Connect (OIDC) from a third-party Identity Provider
	OidcAuthEnabled bool `json:"oidc_auth_enabled"`

	// OrgId ID of the organization
	OrgId openapi_types.UUID `json:"org_id"`

	// PortalId ID of the portal
	PortalId openapi_types.UUID `json:"portal_id"`

	// RbacEnabled Whether Role-Based Access Control is enabled for the portal
	RbacEnabled bool `json:"rbac_enabled"`

	// SamlAuthEnabled Whether the portal can be accessed via SAML authentication
	SamlAuthEnabled bool `json:"saml_auth_enabled"`
}

// PortalCustomization The custom settings of this portal
type PortalCustomization struct {
	Css    *string `json:"css"`
	Layout *string `json:"layout,omitempty"`
	Menu   *struct {
		FooterBottom   *[]PortalMenuItem          `json:"footer_bottom,omitempty"`
		FooterSections *[]PortalFooterMenuSection `json:"footer_sections,omitempty"`
		Main           *[]PortalMenuItem          `json:"main,omitempty"`
	} `json:"menu,omitempty"`
	Robots       *string `json:"robots"`
	SpecRenderer *struct {
		InfiniteScroll *bool `json:"infinite_scroll,omitempty"`
		ShowSchemas    *bool `json:"show_schemas,omitempty"`
		TryItInsomnia  *bool `json:"try_it_insomnia,omitempty"`
		TryItUi        *bool `json:"try_it_ui,omitempty"`
	} `json:"spec_renderer,omitempty"`
	Theme *struct {
		Colors *struct {
			Primary *string `json:"primary,omitempty"`
		} `json:"colors,omitempty"`
		Mode *PortalCustomizationThemeMode `json:"mode,omitempty"`
		Name *string                       `json:"name,omitempty"`
	} `json:"theme,omitempty"`
}

// PortalCustomizationThemeMode defines model for PortalCustomization.Theme.Mode.
type PortalCustomizationThemeMode string

// PortalFooterMenuSection defines model for PortalFooterMenuSection.
type PortalFooterMenuSection struct {
	Items []PortalMenuItem `json:"items"`

	// Title The footer menu section title
	Title string `json:"title"`
}

// PortalMenuItem defines model for PortalMenuItem.
type PortalMenuItem struct {
	// External When clicked, open the link in a new window
	External bool `json:"external"`

	// Path The absolute path of a page in a portal with a leading slash.
	Path string `json:"path"`

	// Title The link display text
	Title string `json:"title"`

	// Visibility Whether a menu item is public or private. Private menu items are only accessible to authenticated users.
	Visibility PortalMenuItemVisibility `json:"visibility"`
}

// PortalMenuItemVisibility Whether a menu item is public or private. Private menu items are only accessible to authenticated users.
type PortalMenuItemVisibility string

// PortalPage A single page for the portal
type PortalPage struct {
	// Content The renderable markdown content of the page
	Content PageContent `json:"content"`

	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt   *CreatedAt   `json:"created_at,omitempty"`
	Description *Description `json:"description,omitempty"`

	// Id The unique identifier of the page
	Id PageId `json:"id"`

	// ParentPageId Pages may be rendered as a tree of files.
	ParentPageId *ParentPageId `json:"parent_page_id"`

	// Slug The slug of the page.
	Slug PageSlug `json:"slug"`

	// Title The title of the page
	Title PageTitle `json:"title"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`

	// Visibility Whether the page or snippet is public or private. Private pages and snippets are only accessible to authenticated users.
	Visibility Visibility `json:"visibility"`
}

// PortalPageInfo A single page for the portal
type PortalPageInfo struct {
	// Children children of the page
	Children []PortalPageInfo `json:"children"`

	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt   *CreatedAt   `json:"created_at,omitempty"`
	Description *Description `json:"description,omitempty"`

	// Id The unique identifier of the page
	Id PageId `json:"id"`

	// ParentPageId Pages may be rendered as a tree of files.
	ParentPageId *ParentPageId `json:"parent_page_id"`

	// Slug The slug of the page.
	Slug PageSlug `json:"slug"`

	// Title The title of the page
	Title PageTitle `json:"title"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`

	// Visibility Whether the page or snippet is public or private. Private pages and snippets are only accessible to authenticated users.
	Visibility Visibility `json:"visibility"`
}

// PortalSearchQueryParameters defines model for PortalSearchQueryParameters.
type PortalSearchQueryParameters = string

// PortalSearchResultDocument defines model for PortalSearchResultDocument.
type PortalSearchResultDocument struct {
	// Attributes Attributes for the entity.
	Attributes struct {
		// ApiSlug The URL slug of the API.
		ApiSlug string `json:"api_slug"`

		// CreatedAt An ISO-8601 timestamp representation of entity creation date.
		CreatedAt *CreatedAt `json:"created_at,omitempty"`

		// ParentDocumentId The ID of the parent document if one exists.
		ParentDocumentId string `json:"parent_document_id"`

		// Path The path of the operation.
		Path string `json:"path"`

		// Scope The scope of the operation.
		Scope string `json:"scope"`

		// Slug The URL slug of the document.
		Slug string `json:"slug"`

		// UpdatedAt An ISO-8601 timestamp representation of entity update date.
		UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`
	} `json:"attributes"`

	// Description Description of the entity.
	Description string `json:"description"`

	// Id Unique identifier for the record.
	Id string `json:"id"`

	// Match The matched text from the record.
	Match string `json:"match"`

	// Name Name of the entity.
	Name string `json:"name"`

	// Relations Relations for the entity.
	Relations struct {
		// ApiDescription The description of the API.
		ApiDescription string `json:"api_description"`

		// ApiId The ID of the API.
		ApiId string `json:"api_id"`

		// ApiSlug The slug of the API.
		ApiSlug string `json:"api_slug"`

		// ApiVersion The version of the API.
		ApiVersion string `json:"api_version"`

		// OrgId The ID of the organization.
		OrgId string `json:"org_id"`

		// ParentDocumentId The ID of the parent document if one exists.
		ParentDocumentId string `json:"parent_document_id"`

		// Path The path of the document.
		Path string `json:"path"`

		// PortalId The ID of the portal.
		PortalId string `json:"portal_id"`

		// Slug The URL slug of the document.
		Slug string `json:"slug"`

		// SpecId The ID of the API specification.
		SpecId string `json:"spec_id"`
	} `json:"relations"`

	// Type Portal entity type.
	Type string `json:"type"`
}

// PortalSearchResultOperation defines model for PortalSearchResultOperation.
type PortalSearchResultOperation struct {
	// Attributes Attributes for the entity.
	Attributes struct {
		// ApiDescription The description of the API.
		ApiDescription string `json:"api_description"`

		// ApiName The name of the API.
		ApiName string `json:"api_name"`

		// ApiSlug The URL slug of the API.
		ApiSlug string `json:"api_slug"`

		// ApiVersion The version of the API.
		ApiVersion string `json:"api_version"`

		// CreatedAt An ISO-8601 timestamp representation of entity creation date.
		CreatedAt *CreatedAt `json:"created_at,omitempty"`

		// Method The method of the operation.
		Method string `json:"method"`

		// OperationId The operation ID of the operation.
		OperationId string `json:"operation_id"`

		// OperationKey The operation key of the operation.
		OperationKey string `json:"operation_key"`

		// Path The path of the operation.
		Path string `json:"path"`

		// Scope The scope of the operation.
		Scope string `json:"scope"`

		// Summary The summary of the operation.
		Summary string `json:"summary"`

		// UpdatedAt An ISO-8601 timestamp representation of entity update date.
		UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`
	} `json:"attributes"`

	// Description Description of the entity.
	Description string `json:"description"`

	// Id Unique identifier for the record.
	Id string `json:"id"`

	// Match The matched text from the record.
	Match string `json:"match"`

	// Name Name of the entity.
	Name string `json:"name"`

	// Relations Relations for the entity.
	Relations struct {
		// ApiDescription The description of the API.
		ApiDescription string `json:"api_description"`

		// ApiId The ID of the API.
		ApiId string `json:"api_id"`

		// ApiName The name of the API.
		ApiName string `json:"api_name"`

		// ApiSlug The slug of the API.
		ApiSlug string `json:"api_slug"`

		// ApiVersion The version of the API.
		ApiVersion string `json:"api_version"`

		// OrgId The ID of the organization.
		OrgId string `json:"org_id"`

		// PortalId The ID of the portal.
		PortalId string `json:"portal_id"`

		// SpecId The ID of the API specification.
		SpecId string `json:"spec_id"`
	} `json:"relations"`

	// Type Portal entity type.
	Type string `json:"type"`
}

// PortalSearchResults defines model for PortalSearchResults.
type PortalSearchResults struct {
	// Data The paginated results that matched the search query
	Data []PortalSearchResults_Data_Item `json:"data"`

	// Meta Pagination metadata.
	Meta CursorMeta `json:"meta"`
}

// PortalSearchResults_Data_Item defines model for PortalSearchResults.data.Item.
type PortalSearchResults_Data_Item struct {
	union json.RawMessage
}

// PortalSnippet A single snippet for the portal
type PortalSnippet struct {
	// Content The renderable markdown content of the snippet
	Content SnippetContent `json:"content"`

	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt   *CreatedAt   `json:"created_at,omitempty"`
	Description *Description `json:"description,omitempty"`

	// Id The unique identifier of the page
	Id PageId `json:"id"`

	// Name The name of the snippet (no leading slash)
	Name SnippetName `json:"name"`

	// Title The title of the snippet
	Title SnippetTitle `json:"title"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`

	// Visibility Whether the page or snippet is public or private. Private pages and snippets are only accessible to authenticated users.
	Visibility Visibility `json:"visibility"`
}

// PortalSnippetInfo A single snippet for the portal
type PortalSnippetInfo struct {
	// CreatedAt An ISO-8601 timestamp representation of entity creation date.
	CreatedAt   *CreatedAt   `json:"created_at,omitempty"`
	Description *Description `json:"description,omitempty"`

	// Id The unique identifier of the snippet
	Id SnippetId `json:"id"`

	// Name The name of the snippet (no leading slash)
	Name SnippetName `json:"name"`

	// Title The title of the snippet
	Title SnippetTitle `json:"title"`

	// UpdatedAt An ISO-8601 timestamp representation of entity update date.
	UpdatedAt *UpdatedAt `json:"updated_at,omitempty"`

	// Visibility Whether the page or snippet is public or private. Private pages and snippets are only accessible to authenticated users.
	Visibility Visibility `json:"visibility"`
}

// QueryApplicationAnalytics defines model for QueryApplicationAnalytics.
type QueryApplicationAnalytics struct {
	// Dimensions The dimensions for the query.  A query may have up to 2 dimensions, including time.
	// If no dimensions are provided, the report will simply return the provided metric aggregated across
	// all available data.
	Dimensions *[]QueryApplicationAnalyticsDimensions    `json:"dimensions,omitempty"`
	Filters    *[]QueryApplicationAnalytics_Filters_Item `json:"filters,omitempty"`

	// Granularity `granularity` is only valid for queries that include a time dimension, and it specifies the time buckets in for the returned data.
	Granularity *QueryApplicationAnalyticsGranularity `json:"granularity,omitempty"`

	// Metrics A property of your API (such as request count or latency) that you wish to query on.
	// Your chosen metric is aggregated within the specified dimensions, meaning that if you query 'request count by application', you'll receive the total number of requests each application received within the given time frame.
	Metrics *[]QueryApplicationAnalyticsMetrics `json:"metrics,omitempty"`

	// TimeRange The time range to query.
	TimeRange *QueryApplicationAnalytics_TimeRange `json:"time_range,omitempty"`
}

// QueryApplicationAnalyticsDimensions defines model for QueryApplicationAnalytics.Dimensions.
type QueryApplicationAnalyticsDimensions string

// QueryApplicationAnalytics_Filters_Item defines model for QueryApplicationAnalytics.filters.Item.
type QueryApplicationAnalytics_Filters_Item struct {
	union json.RawMessage
}

// QueryApplicationAnalyticsGranularity `granularity` is only valid for queries that include a time dimension, and it specifies the time buckets in for the returned data.
type QueryApplicationAnalyticsGranularity string

// QueryApplicationAnalyticsMetrics defines model for QueryApplicationAnalytics.Metrics.
type QueryApplicationAnalyticsMetrics string

// QueryApplicationAnalytics_TimeRange The time range to query.
type QueryApplicationAnalytics_TimeRange struct {
	union json.RawMessage
}

// QueryResponseData Query response data.
type QueryResponseData = []QueryResponseEvent

// QueryResponseEvent A response record.
type QueryResponseEvent struct {
	// Event Event within the response. Mapping from the requested metrics and dimensions to the values.
	Event *struct {
		// Api Id representing an API
		Api *string `json:"api,omitempty"`

		// Application Id representing an Application
		Application *string `json:"application,omitempty"`

		// RequestCount The number or requests metric.
		RequestCount *int `json:"request_count,omitempty"`

		// RequestPerMinute The number of requests per minute metric.
		RequestPerMinute *float32 `json:"request_per_minute,omitempty"`

		// RequestSizeAverage Average request size metric in bytes.
		RequestSizeAverage *float32 `json:"request_size_average,omitempty"`

		// RequestSizeSum Sum request size metric in bytes.
		RequestSizeSum *float32 `json:"request_size_sum,omitempty"`

		// ResponseLatencyAverage Average response latency metric in milliseconds.
		ResponseLatencyAverage *float32 `json:"response_latency_average,omitempty"`

		// ResponseSizeAverage Average response size metric in bytes.
		ResponseSizeAverage *float32 `json:"response_size_average,omitempty"`

		// ResponseSizeSum Sum response size metric in bytes.
		ResponseSizeSum *float32 `json:"response_size_sum,omitempty"`

		// StatusCode Value for status_code.
		StatusCode *string `json:"status_code,omitempty"`

		// StatusCodeGrouped Value for status_code_grouped.
		StatusCodeGrouped *string `json:"status_code_grouped,omitempty"`
	} `json:"event,omitempty"`

	// Timestamp An ISO-8601 timestamp. If `time` was requested as a dimension this will be the start of the time bucket. If not specified this is the start time of the query.
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// QueryResponseMeta Query response metadata.
type QueryResponseMeta struct {
	// Display The blob represents how to interpret large UUID strings in the `data` response. The structure is records of dimension_id ->  ID -> entity metadata. Since entity names within Konnect may overlap, ids are returned and used for exact grouping. This blob may be used to join and display results in a more human friendly manner. Since IDs represent entities in the system at all points in time, historical data will still exist even if an entity is deleted. These such entities are marked with the `deleted` key.
	//
	// Another special case is the ____OTHER____ entity. When the limit of cardinality is reached for a second dimension, the system will group all other entities into the ____OTHER____ grouping. This prevents returning an overwhelming number of long tail entities.
	Display *DisplayBlob `json:"display,omitempty"`

	// End End of the query time range.
	End *time.Time `json:"end,omitempty"`

	// GranularityMs The resulting time bucket for the returned data. If `time` was not specified as a dimension, granularity is the duration of the query.
	GranularityMs *int `json:"granularity_ms,omitempty"`

	// Limit Applied query cardinality limit.
	Limit *float32 `json:"limit,omitempty"`

	// MetricNames The metric requested in query.
	MetricNames *[]QueryResponseMetaMetricNames `json:"metric_names,omitempty"`

	// MetricUnits The unit of metric.
	MetricUnits *struct {
		RequestCount           *string `json:"request_count,omitempty"`
		RequestPerMinute       *string `json:"request_per_minute,omitempty"`
		RequestSizeAverage     *string `json:"request_size_average,omitempty"`
		RequestSizeSum         *string `json:"request_size_sum,omitempty"`
		ResponseLatencyAverage *string `json:"response_latency_average,omitempty"`
		ResponseSizeAverage    *string `json:"response_size_average,omitempty"`
		ResponseSizeSum        *string `json:"response_size_sum,omitempty"`
	} `json:"metric_units,omitempty"`

	// QueryId Optional ID used to look up the query.
	QueryId *string `json:"query_id,omitempty"`

	// Start Start of the query time range.
	Start *time.Time `json:"start,omitempty"`

	// Truncated True if the limit of dimension values was reached and results were truncated. Limit value is 50.
	Truncated *bool `json:"truncated,omitempty"`
}

// QueryResponseMetaMetricNames defines model for QueryResponseMeta.MetricNames.
type QueryResponseMetaMetricNames string

// RefreshedGrantedScopes List of granted scopes, directly updated from the IDP
type RefreshedGrantedScopes = []string

// RegenerateSecretResponse Regenerate secret response
type RegenerateSecretResponse struct {
	ClientId     string `json:"client_id"`
	ClientSecret string `json:"client_secret"`
}

// RegisterPayload Payload required to be sent to register a developer to the
// portal.
type RegisterPayload struct {
	Email                openapi_types.Email    `json:"email"`
	FullName             string                 `json:"full_name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RelativeTimeRangeDto A duration representing a relative-to-now span of time. Generally the start time is floored to the requested granularity. Eg 7d from now, with 1day granularity initiated at 2024-01-08T17:11:00+05:00 will query for the time range from 2024-01-01T00:00:00+05:00 to 2024-01-08T17:11:00+05:00. The exact start and end timestamps are returned in the result query in the meta.start and meta.end fields. If the granularity for the previous query was 1hour, it would query a time range from 2024-01-01T17:00:00+05:00 to 2024-01-08T17:11:00+05:00.
type RelativeTimeRangeDto struct {
	TimeRange RelativeTimeRangeDtoTimeRange `json:"time_range"`
	Type      RelativeTimeRangeDtoType      `json:"type"`
	Tz        *string                       `json:"tz,omitempty"`
}

// RelativeTimeRangeDtoTimeRange defines model for RelativeTimeRangeDto.TimeRange.
type RelativeTimeRangeDtoTimeRange string

// RelativeTimeRangeDtoType defines model for RelativeTimeRangeDto.Type.
type RelativeTimeRangeDtoType string

// ResetPasswordPayload Payload required to start the reset password flow
type ResetPasswordPayload struct {
	Email openapi_types.Email `json:"email"`
}

// ResetPasswordRequest The request schema for the reset password endpoint.
type ResetPasswordRequest struct {
	Password *string             `json:"password,omitempty"`
	Token    *openapi_types.UUID `json:"token,omitempty"`
}

// Scopes The granted scopes for the application. Will only be included if supported by the application's auth strategy.
type Scopes = []string

// SnippetContent The renderable markdown content of the snippet
type SnippetContent = string

// SnippetId The unique identifier of the snippet
type SnippetId = openapi_types.UUID

// SnippetName The name of the snippet (no leading slash)
type SnippetName = string

// SnippetTitle The title of the snippet
type SnippetTitle = string

// SortQuery The `asc` suffix is optional as the default sort order is ascending.
// The `desc` suffix is used to specify a descending order.
// Multiple sort attributes may be provided via a comma separated list.
// JSONPath notation may be used to specify a sub-attribute (eg: 'foo.bar desc').
type SortQuery = string

// StatusCodeFilter defines model for StatusCodeFilter.
type StatusCodeFilter struct {
	// Field The dimension to filter.
	Field StatusCodeFilterField `json:"field"`

	// Operator The type of filter to apply.  `in` filters will limit results to only the specified values, while `not_in` filters will exclude the specified values.
	Operator FilterType `json:"operator"`

	// Value Only include requests with specific status codes in the results.
	Value []int `json:"value"`
}

// StatusCodeFilterField The dimension to filter.
type StatusCodeFilterField string

// StatusCodeGroupedFilter defines model for StatusCodeGroupedFilter.
type StatusCodeGroupedFilter struct {
	// Field The dimension to filter.
	Field StatusCodeGroupedFilterField `json:"field"`

	// Operator The type of filter to apply.  `in` filters will limit results to only the specified values, while `not_in` filters will exclude the specified values.
	Operator FilterType `json:"operator"`

	// Value Only include the given groups of status codes in the results.
	Value []string `json:"value"`
}

// StatusCodeGroupedFilterField The dimension to filter.
type StatusCodeGroupedFilterField string

// StringFieldContainsFilter Filters on the given string field value by fuzzy match.
type StringFieldContainsFilter struct {
	Contains string `json:"contains"`
}

// StringFieldEqualsFilter Filters on the given string field value by exact match.
type StringFieldEqualsFilter struct {
	union json.RawMessage
}

// StringFieldEqualsFilter0 defines model for .
type StringFieldEqualsFilter0 = string

// StringFieldEqualsFilter1 defines model for .
type StringFieldEqualsFilter1 struct {
	Eq string `json:"eq"`
}

// StringFieldFilter Filters on the given string field value by either exact or fuzzy match.
type StringFieldFilter struct {
	union json.RawMessage
}

// StringFieldNEQFilter Filters on the given string field value by exact match inequality.
type StringFieldNEQFilter struct {
	Neq string `json:"neq"`
}

// StringFieldOContainsFilter Returns entities that fuzzy-match any of the comma-delimited phrases in the filter string.
type StringFieldOContainsFilter struct {
	Ocontains string `json:"ocontains"`
}

// StringFieldOEQFilter Returns entities that exact match any of the comma-delimited phrases in the filter string.
type StringFieldOEQFilter struct {
	Oeq string `json:"oeq"`
}

// TooManyRequestsError defines model for TooManyRequestsError.
type TooManyRequestsError struct {
	Detail   interface{} `json:"detail"`
	Instance interface{} `json:"instance"`
	Status   interface{} `json:"status"`
	Title    interface{} `json:"title"`
	Type     interface{} `json:"type,omitempty"`
}

// UUID Contains a unique identifier used for this resource.
type UUID = openapi_types.UUID

// UnauthorizedError defines model for UnauthorizedError.
type UnauthorizedError struct {
	Detail   interface{} `json:"detail"`
	Instance interface{} `json:"instance"`
	Status   interface{} `json:"status"`
	Title    interface{} `json:"title"`
	Type     interface{} `json:"type,omitempty"`
}

// UnprocessableContentError defines model for UnprocessableContentError.
type UnprocessableContentError struct {
	Detail   interface{} `json:"detail"`
	Instance interface{} `json:"instance"`
	Status   interface{} `json:"status"`
	Title    interface{} `json:"title"`
	Type     interface{} `json:"type,omitempty"`
}

// UpdateApplicationPayload Payload required to update an application
type UpdateApplicationPayload struct {
	// ClientId A unique value used to identify the portal application when authenticating with a Client Secret.
	ClientId *ApplicationClientId `json:"client_id,omitempty"`

	// Description A brief description of the application
	Description *string `json:"description,omitempty"`

	// Name The name of the application
	Name *string `json:"name,omitempty"`

	// RedirectUri URL to redirect to after completing an OIDC auth flow
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// Scopes The granted scopes for the application. Will only be included if supported by the application's auth strategy.
	Scopes *Scopes `json:"scopes,omitempty"`
}

// UpdateCredentialRequest defines model for UpdateCredentialRequest.
type UpdateCredentialRequest struct {
	DisplayName string `json:"display_name"`
}

// UpdatedAt An ISO-8601 timestamp representation of entity update date.
type UpdatedAt = time.Time

// UuidFieldFilter Filters on the given UUID field value by exact match.
type UuidFieldFilter struct {
	union json.RawMessage
}

// VerifyEmailRequest The request schema for the verify email endpoint.
type VerifyEmailRequest struct {
	Token *openapi_types.UUID `json:"token,omitempty"`
}

// VerifyEmailResponse The response schema for the verify email endpoint.
type VerifyEmailResponse struct {
	Email *openapi_types.Email `json:"email,omitempty"`
	Token *openapi_types.UUID  `json:"token,omitempty"`
}

// Visibility Whether the page or snippet is public or private. Private pages and snippets are only accessible to authenticated users.
type Visibility string

// ApiAttributeFilters defines model for ApiAttributeFilters.
type ApiAttributeFilters = ApiAttributeFilterParameters

// ApiFilters defines model for ApiFilters.
type ApiFilters = ApiFilterParameters

// ApiIdOrSlug defines model for ApiIdOrSlug.
type ApiIdOrSlug struct {
	union json.RawMessage
}

// ApiSort The `asc` suffix is optional as the default sort order is ascending.
// The `desc` suffix is used to specify a descending order.
// Multiple sort attributes may be provided via a comma separated list.
// JSONPath notation may be used to specify a sub-attribute (eg: 'foo.bar desc').
type ApiSort = SortQuery

// ApplicationFilters defines model for ApplicationFilters.
type ApplicationFilters = ApplicationFilterParameter

// ApplicationId defines model for ApplicationId.
type ApplicationId = openapi_types.UUID

// CredentialId defines model for CredentialId.
type CredentialId = openapi_types.UUID

// DocumentIdOrSlug defines model for DocumentIdOrSlug.
type DocumentIdOrSlug struct {
	union json.RawMessage
}

// FilterByAPINameContains defines model for FilterByAPINameContains.
type FilterByAPINameContains = string

// FilterByAPINameEquality defines model for FilterByAPINameEquality.
type FilterByAPINameEquality = string

// FilterByAPINameEqualityShort defines model for FilterByAPINameEqualityShort.
type FilterByAPINameEqualityShort = string

// FilterByAuthStrategyEquality defines model for FilterByAuthStrategyEquality.
type FilterByAuthStrategyEquality = string

// FilterByAuthStrategyEqualityShort defines model for FilterByAuthStrategyEqualityShort.
type FilterByAuthStrategyEqualityShort = string

// FilterByCredentialTypeEquality defines model for FilterByCredentialTypeEquality.
type FilterByCredentialTypeEquality string

// FilterByIdEquality defines model for FilterByIdEquality.
type FilterByIdEquality = string

// FilterByIdEqualityShort defines model for FilterByIdEqualityShort.
type FilterByIdEqualityShort = string

// FilterByNameContains defines model for FilterByNameContains.
type FilterByNameContains = string

// FilterByNameEquality defines model for FilterByNameEquality.
type FilterByNameEquality = string

// FilterByNameEqualityShort defines model for FilterByNameEqualityShort.
type FilterByNameEqualityShort = string

// FilterBySlugContains defines model for FilterBySlugContains.
type FilterBySlugContains = string

// FilterBySlugEquality defines model for FilterBySlugEquality.
type FilterBySlugEquality = string

// FilterBySlugEqualityShort defines model for FilterBySlugEqualityShort.
type FilterBySlugEqualityShort = string

// FilterByStatusEquality defines model for FilterByStatusEquality.
type FilterByStatusEquality string

// FilterByStatusEqualityShort defines model for FilterByStatusEqualityShort.
type FilterByStatusEqualityShort string

// FilterByTitleContains defines model for FilterByTitleContains.
type FilterByTitleContains = string

// FilterByTitleEquality defines model for FilterByTitleEquality.
type FilterByTitleEquality = string

// FilterByTitleEqualityShort defines model for FilterByTitleEqualityShort.
type FilterByTitleEqualityShort = string

// FilterByVisibilityEquality defines model for FilterByVisibilityEquality.
type FilterByVisibilityEquality string

// FilterByVisibilityEqualityShort defines model for FilterByVisibilityEqualityShort.
type FilterByVisibilityEqualityShort string

// PageAfter defines model for PageAfter.
type PageAfter = string

// PageNumber defines model for PageNumber.
type PageNumber = int

// PageSize defines model for PageSize.
type PageSize = int

// PortalSearchQuery defines model for PortalSearchQuery.
type PortalSearchQuery = PortalSearchQueryParameters

// QueryUnregisteredApplications defines model for QueryUnregisteredApplications.
type QueryUnregisteredApplications = bool

// RegistrationId defines model for RegistrationId.
type RegistrationId = openapi_types.UUID

// SelectedApiAttributes defines model for SelectedApiAttributes.
type SelectedApiAttributes map[string]string

// SortPortalPages defines model for SortPortalPages.
type SortPortalPages = string

// SortPortalSnippets defines model for SortPortalSnippets.
type SortPortalSnippets = string

// SpecId defines model for SpecId.
type SpecId = openapi_types.UUID

// VersionId defines model for VersionId.
type VersionId = openapi_types.UUID

// PagePath defines model for pagePath.
type PagePath = string

// SnippetNameParam defines model for snippetName.
type SnippetNameParam = string

// ApiActions defines model for ApiActions.
type ApiActions = ApiActionsResponse

// ApiDocumentGet A document for an API. This is a document that is not a part of the API specification.
type ApiDocumentGet = ApiDocument

// ApiDocumentList defines model for ApiDocumentList.
type ApiDocumentList struct {
	Data []ApiDocumentTree `json:"data"`
}

// ApiGet defines model for ApiGet.
type ApiGet = Api

// ApiList defines model for ApiList.
type ApiList = ApiListPage

// ApiListApplications defines model for ApiListApplications.
type ApiListApplications = ApiListApplicationsPage

// ApiSpecGet API specification document.
type ApiSpecGet = ApiSpecDocument

// ApiSpecGetRaw defines model for ApiSpecGetRaw.
type ApiSpecGetRaw = string

// ApiSpecList defines model for ApiSpecList.
type ApiSpecList struct {
	Data []ApiSpecDocumentSummary `json:"data"`

	// Meta returns the pagination information
	Meta PaginatedMeta `json:"meta"`
}

// ApiVersionGet Singular version of an API
type ApiVersionGet = ApiVersion

// ApiVersionGetRaw JSON content of the API specification.
type ApiVersionGetRaw = map[string]interface{}

// ApiVersionList defines model for ApiVersionList.
type ApiVersionList struct {
	Data []ApiVersionSummary `json:"data"`

	// Meta returns the pagination information
	Meta PaginatedMeta `json:"meta"`
}

// ApplicationCreation Application creation response payload
type ApplicationCreation = ApplicationCreationResponse

// ApplicationUpdate Application update response payload
type ApplicationUpdate = ApplicationUpdateResponse

// BadRequest defines model for BadRequest.
type BadRequest = BadRequestError

// Conflict defines model for Conflict.
type Conflict = ConflictError

// CreateAPIRegistrationResponse defines model for CreateAPIRegistrationResponse.
type CreateAPIRegistrationResponse = GetApiRegistrationResponse

// CredentialCreation defines model for CredentialCreation.
type CredentialCreation = CredentialCreationResponse

// Forbidden defines model for Forbidden.
type Forbidden = ForbiddenError

// GetAPIRegistration defines model for GetAPIRegistration.
type GetAPIRegistration = GetApiRegistrationResponse

// GetApplication defines model for GetApplication.
type GetApplication = GetApplicationResponse

// GetConfig defines model for GetConfig.
type GetConfig = GetConfigResponse

// GetGrantedScopesAPI defines model for GetGrantedScopesAPI.
type GetGrantedScopesAPI = GetGrantedScopesAPIResponse

// GetGrantedScopesAPI422Response defines model for GetGrantedScopesAPI422Response.
type GetGrantedScopesAPI422Response = UnprocessableContentError

// GetPortalContextResponse Describes the portal execution context
type GetPortalContextResponse = PortalContext

// GetPortalPageResponse A single page for the portal
type GetPortalPageResponse = PortalPage

// GetPortalSnippetResponse A single snippet for the portal
type GetPortalSnippetResponse = PortalSnippet

// Gone defines model for Gone.
type Gone = GoneError

// ListApiAttributes defines model for ListApiAttributes.
type ListApiAttributes = ListApiAttributesPage

// ListApiRegistrations defines model for ListApiRegistrations.
type ListApiRegistrations = ListApiRegistrationsResponse

// ListApplications defines model for ListApplications.
type ListApplications = ListApplicationsResponse

// ListAuthStrategies defines model for ListAuthStrategies.
type ListAuthStrategies = ListAuthStrategiesResponse

// ListCredentials defines model for ListCredentials.
type ListCredentials = ListCredentialsResponse

// ListPortalPagesResponse A paginated list of pages for the portal
type ListPortalPagesResponse = ListPortalPages

// ListPortalSnippetsResponse A paginated list of snippets for the portal
type ListPortalSnippetsResponse = ListPortalSnippets

// MeResponse A user who can use a developer portal
type MeResponse = Developer

// NotAvailable standard error
type NotAvailable = BaseError

// NotFound defines model for NotFound.
type NotFound = NotFoundError

// PortalCustomizationResponse The custom settings of this portal
type PortalCustomizationResponse = PortalCustomization

// PortalSearchResponse defines model for PortalSearchResponse.
type PortalSearchResponse = PortalSearchResults

// PostCredentials403Response defines model for PostCredentials403Response.
type PostCredentials403Response = ForbiddenError

// QueryResponse defines model for QueryResponse.
type QueryResponse struct {
	// Data Query response data.
	Data *QueryResponseData `json:"data,omitempty"`

	// Meta Query response metadata.
	Meta *QueryResponseMeta `json:"meta,omitempty"`
}

// RegenerateSecret Regenerate secret response
type RegenerateSecret = RegenerateSecretResponse

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = TooManyRequestsError

// Unauthorized defines model for Unauthorized.
type Unauthorized = UnauthorizedError

// ResponsesUnauthorized defines model for responses-Unauthorized.
type ResponsesUnauthorized = UnauthorizedError

// CreateAPIRegistration The payload to create a registration.
type CreateAPIRegistration = CreateApiRegistrationPayload

// CreateApplication Application creation payload
type CreateApplication = CreateApplicationPayload

// CreateCredential defines model for CreateCredential.
type CreateCredential = CreateCredentialRequest

// UpdateApplication Payload required to update an application
type UpdateApplication = UpdateApplicationPayload

// UpdateCredential defines model for UpdateCredential.
type UpdateCredential = UpdateCredentialRequest

// GetPaginatedApiAttributesParams defines parameters for GetPaginatedApiAttributes.
type GetPaginatedApiAttributesParams struct {
	// Filter Filters API attributes in the response.
	Filter *ApiAttributeFilters `json:"filter,omitempty"`

	// Selected Specifies selected attribute values to calculate filtered API counts.
	// Use the format: selected[<attribute_key>]=<attribute_value_1>,<attribute_value_2>
	// When provided, the response will include selected_api_count for each attribute value.
	Selected *SelectedApiAttributes `json:"selected,omitempty"`
}

// ListApisParams defines parameters for ListApis.
type ListApisParams struct {
	// Filter Filters APIs in the response.
	Filter *ApiFilters `json:"filter,omitempty"`

	// Sort Sorts a collection of APIs. Supported sort attributes are:
	//   - name
	//   - version
	//   - created_at
	//   - updated_at
	Sort *ApiSort `form:"sort,omitempty" json:"sort,omitempty"`

	// PageSize The maximum number of items to include per page. The last page of a collection may include fewer items.
	PageSize *PageSize `form:"page[size],omitempty" json:"page[size],omitempty"`

	// PageNumber Determines which page of the entities to retrieve.
	PageNumber *PageNumber `form:"page[number],omitempty" json:"page[number],omitempty"`
}

// GetApiApplicationsParams defines parameters for GetApiApplications.
type GetApiApplicationsParams struct {
	// Unregistered Return applications that do **not** have a registration for the API (regardless of registration status).
	Unregistered *QueryUnregisteredApplications `form:"unregistered,omitempty" json:"unregistered,omitempty"`

	// Applicationfilter Filters Applications to retrieve.
	Applicationfilter *ApplicationFilters `json:"applicationfilter,omitempty"`

	// PageSize The maximum number of items to include per page. The last page of a collection may include fewer items.
	PageSize *PageSize `form:"page[size],omitempty" json:"page[size],omitempty"`

	// PageNumber Determines which page of the entities to retrieve.
	PageNumber *PageNumber `form:"page[number],omitempty" json:"page[number],omitempty"`
}

// FetchApiDocumentParams defines parameters for FetchApiDocument.
type FetchApiDocumentParams struct {
	Accept *DocumentFormatContentTypeEnum `json:"Accept,omitempty"`
}

// ListApplicationAuthStrategiesParams defines parameters for ListApplicationAuthStrategies.
type ListApplicationAuthStrategiesParams struct {
	// PageSize The maximum number of items to include per page. The last page of a collection may include fewer items.
	PageSize *PageSize `form:"page[size],omitempty" json:"page[size],omitempty"`

	// PageNumber Determines which page of the entities to retrieve.
	PageNumber *PageNumber `form:"page[number],omitempty" json:"page[number],omitempty"`

	// FilterNameEq Filter by direct equality comparison of the name property with a supplied value.
	FilterNameEq *FilterByNameEquality `form:"filter[name][eq],omitempty" json:"filter[name][eq],omitempty"`

	// FilterName Filter by direct equality comparison (short-hand) of the name property with a supplied value.
	FilterName *FilterByNameEqualityShort `form:"filter[name],omitempty" json:"filter[name],omitempty"`

	// FilterNameContains Filter by contains comparison of the name property with a supplied substring
	FilterNameContains *FilterByNameContains `form:"filter[name][contains],omitempty" json:"filter[name][contains],omitempty"`

	// FilterCredentialTypeEq Filter by direct equality comparison of the credential_type with a supplied value.
	FilterCredentialTypeEq *ListApplicationAuthStrategiesParamsFilterCredentialTypeEq `form:"filter[credential_type][eq],omitempty" json:"filter[credential_type][eq],omitempty"`
}

// ListApplicationAuthStrategiesParamsFilterCredentialTypeEq defines parameters for ListApplicationAuthStrategies.
type ListApplicationAuthStrategiesParamsFilterCredentialTypeEq string

// ListApplicationsParams defines parameters for ListApplications.
type ListApplicationsParams struct {
	// PageSize The maximum number of items to include per page. The last page of a collection may include fewer items.
	PageSize *PageSize `form:"page[size],omitempty" json:"page[size],omitempty"`

	// PageNumber Determines which page of the entities to retrieve.
	PageNumber *PageNumber `form:"page[number],omitempty" json:"page[number],omitempty"`

	// FilterNameEq Filter by direct equality comparison of the name property with a supplied value.
	FilterNameEq *FilterByNameEquality `form:"filter[name][eq],omitempty" json:"filter[name][eq],omitempty"`

	// FilterName Filter by direct equality comparison (short-hand) of the name property with a supplied value.
	FilterName *FilterByNameEqualityShort `form:"filter[name],omitempty" json:"filter[name],omitempty"`

	// FilterNameContains Filter by contains comparison of the name property with a supplied substring
	FilterNameContains *FilterByNameContains `form:"filter[name][contains],omitempty" json:"filter[name][contains],omitempty"`

	// FilterAuthStrategyIdEq Filter by the id of the auth strategy supported by the application.
	FilterAuthStrategyIdEq *FilterByAuthStrategyEquality `form:"filter[auth_strategy_id][eq],omitempty" json:"filter[auth_strategy_id][eq],omitempty"`

	// FilterAuthStrategyId Filter by the id of the auth strategy supported by the application (short-hand).
	FilterAuthStrategyId *FilterByAuthStrategyEqualityShort `form:"filter[auth_strategy_id],omitempty" json:"filter[auth_strategy_id],omitempty"`
}

// ListCredentialsParams defines parameters for ListCredentials.
type ListCredentialsParams struct {
	// PageSize The maximum number of items to include per page. The last page of a collection may include fewer items.
	PageSize *PageSize `form:"page[size],omitempty" json:"page[size],omitempty"`

	// PageNumber Determines which page of the entities to retrieve.
	PageNumber *PageNumber `form:"page[number],omitempty" json:"page[number],omitempty"`
}

// ListApplicationRegistrationsParams defines parameters for ListApplicationRegistrations.
type ListApplicationRegistrationsParams struct {
	// PageSize The maximum number of items to include per page. The last page of a collection may include fewer items.
	PageSize *PageSize `form:"page[size],omitempty" json:"page[size],omitempty"`

	// PageNumber Determines which page of the entities to retrieve.
	PageNumber *PageNumber `form:"page[number],omitempty" json:"page[number],omitempty"`

	// FilterIdEq Filter by direct equality comparison of the id property with a supplied value.
	FilterIdEq *FilterByIdEquality `form:"filter[id][eq],omitempty" json:"filter[id][eq],omitempty"`

	// FilterId Filter by direct equality comparison (short-hand) of the id property with a supplied value.
	FilterId *FilterByIdEqualityShort `form:"filter[id],omitempty" json:"filter[id],omitempty"`

	// FilterStatusEq Filter by direct equality comparison of the status property with a supplied value.
	FilterStatusEq *ListApplicationRegistrationsParamsFilterStatusEq `form:"filter[status][eq],omitempty" json:"filter[status][eq],omitempty"`

	// FilterStatus Filter by direct equality comparison (short-hand) of the status property with a supplied value.
	FilterStatus *ListApplicationRegistrationsParamsFilterStatus `form:"filter[status],omitempty" json:"filter[status],omitempty"`

	// FilterApiNameEq Filter by direct equality comparison of the api_name property with a supplied value.
	FilterApiNameEq *FilterByAPINameEquality `form:"filter[api_name][eq],omitempty" json:"filter[api_name][eq],omitempty"`

	// FilterApiName Filter by direct equality comparison (short-hand) of the api_name property with a supplied value.
	FilterApiName *FilterByAPINameEqualityShort `form:"filter[api_name],omitempty" json:"filter[api_name],omitempty"`

	// FilterApiNameContains Filter by contains comparison of the api_name property with a supplied substring
	FilterApiNameContains *FilterByAPINameContains `form:"filter[api_name][contains],omitempty" json:"filter[api_name][contains],omitempty"`
}

// ListApplicationRegistrationsParamsFilterStatusEq defines parameters for ListApplicationRegistrations.
type ListApplicationRegistrationsParamsFilterStatusEq string

// ListApplicationRegistrationsParamsFilterStatus defines parameters for ListApplicationRegistrations.
type ListApplicationRegistrationsParamsFilterStatus string

// ListPortalPagesParams defines parameters for ListPortalPages.
type ListPortalPagesParams struct {
	// Sort Sorts a collection of portal pages. Supported sort attributes are:
	//   - created_at
	//   - updated_at
	//   - slug
	//   - title
	//   - visibility
	Sort *SortPortalPages `form:"sort,omitempty" json:"sort,omitempty"`

	// FilterTitleEq Filter by direct equality comparison of the title property with a supplied value.
	FilterTitleEq *FilterByTitleEquality `form:"filter[title][eq],omitempty" json:"filter[title][eq],omitempty"`

	// FilterTitle Filter by direct equality comparison (short-hand) of the title property with a supplied value.
	FilterTitle *FilterByTitleEqualityShort `form:"filter[title],omitempty" json:"filter[title],omitempty"`

	// FilterTitleContains Filter by contains comparison of the title property with a supplied substring
	FilterTitleContains *FilterByTitleContains `form:"filter[title][contains],omitempty" json:"filter[title][contains],omitempty"`

	// FilterSlugEq Filter by direct equality comparison of the slug property with a supplied value.
	FilterSlugEq *FilterBySlugEquality `form:"filter[slug][eq],omitempty" json:"filter[slug][eq],omitempty"`

	// FilterSlug Filter by direct equality comparison (short-hand) of the slug property with a supplied value.
	FilterSlug *FilterBySlugEqualityShort `form:"filter[slug],omitempty" json:"filter[slug],omitempty"`

	// FilterSlugContains Filter by contains comparison of the slug property with a supplied substring
	FilterSlugContains *FilterBySlugContains `form:"filter[slug][contains],omitempty" json:"filter[slug][contains],omitempty"`

	// FilterVisibilityEq Filter by whether the pages returned are public or private. Private pages are only accessible to authenticated users. For authenticated users, results will include both public and private pages if not specified.
	FilterVisibilityEq *ListPortalPagesParamsFilterVisibilityEq `form:"filter[visibility][eq],omitempty" json:"filter[visibility][eq],omitempty"`

	// FilterVisibility Filter (short-hand) by whether the pages returned are public or private. Private pages are only accessible to authenticated users. For authenticated users, results will include both public and private pages if not specified.
	FilterVisibility *ListPortalPagesParamsFilterVisibility `form:"filter[visibility],omitempty" json:"filter[visibility],omitempty"`
}

// ListPortalPagesParamsFilterVisibilityEq defines parameters for ListPortalPages.
type ListPortalPagesParamsFilterVisibilityEq string

// ListPortalPagesParamsFilterVisibility defines parameters for ListPortalPages.
type ListPortalPagesParamsFilterVisibility string

// SearchPortalParams defines parameters for SearchPortal.
type SearchPortalParams struct {
	// Q Determines how to filter search results
	Q *PortalSearchQuery `form:"q,omitempty" json:"q,omitempty"`

	// PageSize The maximum number of items to include per page. The last page of a collection may include fewer items.
	PageSize *PageSize `form:"page[size],omitempty" json:"page[size],omitempty"`

	// PageAfter Request the next page of data, starting with the item after this parameter.
	PageAfter *PageAfter `form:"page[after],omitempty" json:"page[after],omitempty"`
}

// ListPortalSnippetsParams defines parameters for ListPortalSnippets.
type ListPortalSnippetsParams struct {
	// Sort Sorts a collection of portal snippets. Supported sort attributes are:
	//   - created_at
	//   - updated_at
	//   - name
	//   - title
	//   - visibility
	Sort *SortPortalSnippets `form:"sort,omitempty" json:"sort,omitempty"`

	// PageSize The maximum number of items to include per page. The last page of a collection may include fewer items.
	PageSize *PageSize `form:"page[size],omitempty" json:"page[size],omitempty"`

	// PageNumber Determines which page of the entities to retrieve.
	PageNumber *PageNumber `form:"page[number],omitempty" json:"page[number],omitempty"`

	// FilterTitleEq Filter by direct equality comparison of the title property with a supplied value.
	FilterTitleEq *FilterByTitleEquality `form:"filter[title][eq],omitempty" json:"filter[title][eq],omitempty"`

	// FilterTitle Filter by direct equality comparison (short-hand) of the title property with a supplied value.
	FilterTitle *FilterByTitleEqualityShort `form:"filter[title],omitempty" json:"filter[title],omitempty"`

	// FilterTitleContains Filter by contains comparison of the title property with a supplied substring
	FilterTitleContains *FilterByTitleContains `form:"filter[title][contains],omitempty" json:"filter[title][contains],omitempty"`

	// FilterNameEq Filter by direct equality comparison of the name property with a supplied value.
	FilterNameEq *FilterByNameEquality `form:"filter[name][eq],omitempty" json:"filter[name][eq],omitempty"`

	// FilterName Filter by direct equality comparison (short-hand) of the name property with a supplied value.
	FilterName *FilterByNameEqualityShort `form:"filter[name],omitempty" json:"filter[name],omitempty"`

	// FilterVisibilityEq Filter by whether the pages returned are public or private. Private pages are only accessible to authenticated users. For authenticated users, results will include both public and private pages if not specified.
	FilterVisibilityEq *ListPortalSnippetsParamsFilterVisibilityEq `form:"filter[visibility][eq],omitempty" json:"filter[visibility][eq],omitempty"`

	// FilterVisibility Filter (short-hand) by whether the pages returned are public or private. Private pages are only accessible to authenticated users. For authenticated users, results will include both public and private pages if not specified.
	FilterVisibility *ListPortalSnippetsParamsFilterVisibility `form:"filter[visibility],omitempty" json:"filter[visibility],omitempty"`
}

// ListPortalSnippetsParamsFilterVisibilityEq defines parameters for ListPortalSnippets.
type ListPortalSnippetsParamsFilterVisibilityEq string

// ListPortalSnippetsParamsFilterVisibility defines parameters for ListPortalSnippets.
type ListPortalSnippetsParamsFilterVisibility string

// CreateApplicationJSONRequestBody defines body for CreateApplication for application/json ContentType.
type CreateApplicationJSONRequestBody = CreateApplicationPayload

// UpdateApplicationJSONRequestBody defines body for UpdateApplication for application/json ContentType.
type UpdateApplicationJSONRequestBody = UpdateApplicationPayload

// CreateCredentialJSONRequestBody defines body for CreateCredential for application/json ContentType.
type CreateCredentialJSONRequestBody = CreateCredentialRequest

// UpdateCredentialJSONRequestBody defines body for UpdateCredential for application/json ContentType.
type UpdateCredentialJSONRequestBody = UpdateCredentialRequest

// CreateApplicationRegistrationJSONRequestBody defines body for CreateApplicationRegistration for application/json ContentType.
type CreateApplicationRegistrationJSONRequestBody = CreateApiRegistrationPayload

// RegisterJSONRequestBody defines body for Register for application/json ContentType.
type RegisterJSONRequestBody = RegisterPayload

// AuthenticateJSONRequestBody defines body for Authenticate for application/json ContentType.
type AuthenticateJSONRequestBody = AuthenticateRequest

// ForgotPasswordJSONRequestBody defines body for ForgotPassword for application/json ContentType.
type ForgotPasswordJSONRequestBody = ResetPasswordPayload

// ResetPasswordJSONRequestBody defines body for ResetPassword for application/json ContentType.
type ResetPasswordJSONRequestBody = ResetPasswordRequest

// VerifyEmailJSONRequestBody defines body for VerifyEmail for application/json ContentType.
type VerifyEmailJSONRequestBody = VerifyEmailRequest

// QueryApplicationAnalyticsJSONRequestBody defines body for QueryApplicationAnalytics for application/json ContentType.
type QueryApplicationAnalyticsJSONRequestBody = QueryApplicationAnalytics

// Getter for additional properties for RegisterPayload. Returns the specified
// element and whether it was found
func (a RegisterPayload) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegisterPayload
func (a *RegisterPayload) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegisterPayload to handle AdditionalProperties
func (a *RegisterPayload) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["email"]; found {
		err = json.Unmarshal(raw, &a.Email)
		if err != nil {
			return fmt.Errorf("error reading 'email': %w", err)
		}
		delete(object, "email")
	}

	if raw, found := object["full_name"]; found {
		err = json.Unmarshal(raw, &a.FullName)
		if err != nil {
			return fmt.Errorf("error reading 'full_name': %w", err)
		}
		delete(object, "full_name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegisterPayload to handle AdditionalProperties
func (a RegisterPayload) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["email"], err = json.Marshal(a.Email)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'email': %w", err)
	}

	object["full_name"], err = json.Marshal(a.FullName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'full_name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsStringFieldEqualsFilter returns the union data inside the AttributesFieldFilter as a StringFieldEqualsFilter
func (t AttributesFieldFilter) AsStringFieldEqualsFilter() (StringFieldEqualsFilter, error) {
	var body StringFieldEqualsFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldEqualsFilter overwrites any union data inside the AttributesFieldFilter as the provided StringFieldEqualsFilter
func (t *AttributesFieldFilter) FromStringFieldEqualsFilter(v StringFieldEqualsFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldEqualsFilter performs a merge with any union data inside the AttributesFieldFilter, using the provided StringFieldEqualsFilter
func (t *AttributesFieldFilter) MergeStringFieldEqualsFilter(v StringFieldEqualsFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldContainsFilter returns the union data inside the AttributesFieldFilter as a StringFieldContainsFilter
func (t AttributesFieldFilter) AsStringFieldContainsFilter() (StringFieldContainsFilter, error) {
	var body StringFieldContainsFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldContainsFilter overwrites any union data inside the AttributesFieldFilter as the provided StringFieldContainsFilter
func (t *AttributesFieldFilter) FromStringFieldContainsFilter(v StringFieldContainsFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldContainsFilter performs a merge with any union data inside the AttributesFieldFilter, using the provided StringFieldContainsFilter
func (t *AttributesFieldFilter) MergeStringFieldContainsFilter(v StringFieldContainsFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldOContainsFilter returns the union data inside the AttributesFieldFilter as a StringFieldOContainsFilter
func (t AttributesFieldFilter) AsStringFieldOContainsFilter() (StringFieldOContainsFilter, error) {
	var body StringFieldOContainsFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldOContainsFilter overwrites any union data inside the AttributesFieldFilter as the provided StringFieldOContainsFilter
func (t *AttributesFieldFilter) FromStringFieldOContainsFilter(v StringFieldOContainsFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldOContainsFilter performs a merge with any union data inside the AttributesFieldFilter, using the provided StringFieldOContainsFilter
func (t *AttributesFieldFilter) MergeStringFieldOContainsFilter(v StringFieldOContainsFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldOEQFilter returns the union data inside the AttributesFieldFilter as a StringFieldOEQFilter
func (t AttributesFieldFilter) AsStringFieldOEQFilter() (StringFieldOEQFilter, error) {
	var body StringFieldOEQFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldOEQFilter overwrites any union data inside the AttributesFieldFilter as the provided StringFieldOEQFilter
func (t *AttributesFieldFilter) FromStringFieldOEQFilter(v StringFieldOEQFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldOEQFilter performs a merge with any union data inside the AttributesFieldFilter, using the provided StringFieldOEQFilter
func (t *AttributesFieldFilter) MergeStringFieldOEQFilter(v StringFieldOEQFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldNEQFilter returns the union data inside the AttributesFieldFilter as a StringFieldNEQFilter
func (t AttributesFieldFilter) AsStringFieldNEQFilter() (StringFieldNEQFilter, error) {
	var body StringFieldNEQFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldNEQFilter overwrites any union data inside the AttributesFieldFilter as the provided StringFieldNEQFilter
func (t *AttributesFieldFilter) FromStringFieldNEQFilter(v StringFieldNEQFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldNEQFilter performs a merge with any union data inside the AttributesFieldFilter, using the provided StringFieldNEQFilter
func (t *AttributesFieldFilter) MergeStringFieldNEQFilter(v StringFieldNEQFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AttributesFieldFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AttributesFieldFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAuthStrategyKeyAuth returns the union data inside the AuthStrategy as a AuthStrategyKeyAuth
func (t AuthStrategy) AsAuthStrategyKeyAuth() (AuthStrategyKeyAuth, error) {
	var body AuthStrategyKeyAuth
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthStrategyKeyAuth overwrites any union data inside the AuthStrategy as the provided AuthStrategyKeyAuth
func (t *AuthStrategy) FromAuthStrategyKeyAuth(v AuthStrategyKeyAuth) error {
	v.CredentialType = "AuthStrategyKeyAuth"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthStrategyKeyAuth performs a merge with any union data inside the AuthStrategy, using the provided AuthStrategyKeyAuth
func (t *AuthStrategy) MergeAuthStrategyKeyAuth(v AuthStrategyKeyAuth) error {
	v.CredentialType = "AuthStrategyKeyAuth"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthStrategyClientCredentials returns the union data inside the AuthStrategy as a AuthStrategyClientCredentials
func (t AuthStrategy) AsAuthStrategyClientCredentials() (AuthStrategyClientCredentials, error) {
	var body AuthStrategyClientCredentials
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthStrategyClientCredentials overwrites any union data inside the AuthStrategy as the provided AuthStrategyClientCredentials
func (t *AuthStrategy) FromAuthStrategyClientCredentials(v AuthStrategyClientCredentials) error {
	v.CredentialType = "AuthStrategyClientCredentials"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthStrategyClientCredentials performs a merge with any union data inside the AuthStrategy, using the provided AuthStrategyClientCredentials
func (t *AuthStrategy) MergeAuthStrategyClientCredentials(v AuthStrategyClientCredentials) error {
	v.CredentialType = "AuthStrategyClientCredentials"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AuthStrategy) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"credential_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AuthStrategy) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "AuthStrategyClientCredentials":
		return t.AsAuthStrategyClientCredentials()
	case "AuthStrategyKeyAuth":
		return t.AsAuthStrategyKeyAuth()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AuthStrategy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AuthStrategy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDateTimeFieldFilter0 returns the union data inside the DateTimeFieldFilter as a DateTimeFieldFilter0
func (t DateTimeFieldFilter) AsDateTimeFieldFilter0() (DateTimeFieldFilter0, error) {
	var body DateTimeFieldFilter0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimeFieldFilter0 overwrites any union data inside the DateTimeFieldFilter as the provided DateTimeFieldFilter0
func (t *DateTimeFieldFilter) FromDateTimeFieldFilter0(v DateTimeFieldFilter0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimeFieldFilter0 performs a merge with any union data inside the DateTimeFieldFilter, using the provided DateTimeFieldFilter0
func (t *DateTimeFieldFilter) MergeDateTimeFieldFilter0(v DateTimeFieldFilter0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateTimeFieldFilter1 returns the union data inside the DateTimeFieldFilter as a DateTimeFieldFilter1
func (t DateTimeFieldFilter) AsDateTimeFieldFilter1() (DateTimeFieldFilter1, error) {
	var body DateTimeFieldFilter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimeFieldFilter1 overwrites any union data inside the DateTimeFieldFilter as the provided DateTimeFieldFilter1
func (t *DateTimeFieldFilter) FromDateTimeFieldFilter1(v DateTimeFieldFilter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimeFieldFilter1 performs a merge with any union data inside the DateTimeFieldFilter, using the provided DateTimeFieldFilter1
func (t *DateTimeFieldFilter) MergeDateTimeFieldFilter1(v DateTimeFieldFilter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateTimeFieldFilter2 returns the union data inside the DateTimeFieldFilter as a DateTimeFieldFilter2
func (t DateTimeFieldFilter) AsDateTimeFieldFilter2() (DateTimeFieldFilter2, error) {
	var body DateTimeFieldFilter2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimeFieldFilter2 overwrites any union data inside the DateTimeFieldFilter as the provided DateTimeFieldFilter2
func (t *DateTimeFieldFilter) FromDateTimeFieldFilter2(v DateTimeFieldFilter2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimeFieldFilter2 performs a merge with any union data inside the DateTimeFieldFilter, using the provided DateTimeFieldFilter2
func (t *DateTimeFieldFilter) MergeDateTimeFieldFilter2(v DateTimeFieldFilter2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateTimeFieldFilter3 returns the union data inside the DateTimeFieldFilter as a DateTimeFieldFilter3
func (t DateTimeFieldFilter) AsDateTimeFieldFilter3() (DateTimeFieldFilter3, error) {
	var body DateTimeFieldFilter3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimeFieldFilter3 overwrites any union data inside the DateTimeFieldFilter as the provided DateTimeFieldFilter3
func (t *DateTimeFieldFilter) FromDateTimeFieldFilter3(v DateTimeFieldFilter3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimeFieldFilter3 performs a merge with any union data inside the DateTimeFieldFilter, using the provided DateTimeFieldFilter3
func (t *DateTimeFieldFilter) MergeDateTimeFieldFilter3(v DateTimeFieldFilter3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateTimeFieldFilter4 returns the union data inside the DateTimeFieldFilter as a DateTimeFieldFilter4
func (t DateTimeFieldFilter) AsDateTimeFieldFilter4() (DateTimeFieldFilter4, error) {
	var body DateTimeFieldFilter4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimeFieldFilter4 overwrites any union data inside the DateTimeFieldFilter as the provided DateTimeFieldFilter4
func (t *DateTimeFieldFilter) FromDateTimeFieldFilter4(v DateTimeFieldFilter4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimeFieldFilter4 performs a merge with any union data inside the DateTimeFieldFilter, using the provided DateTimeFieldFilter4
func (t *DateTimeFieldFilter) MergeDateTimeFieldFilter4(v DateTimeFieldFilter4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateTimeFieldFilter5 returns the union data inside the DateTimeFieldFilter as a DateTimeFieldFilter5
func (t DateTimeFieldFilter) AsDateTimeFieldFilter5() (DateTimeFieldFilter5, error) {
	var body DateTimeFieldFilter5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTimeFieldFilter5 overwrites any union data inside the DateTimeFieldFilter as the provided DateTimeFieldFilter5
func (t *DateTimeFieldFilter) FromDateTimeFieldFilter5(v DateTimeFieldFilter5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTimeFieldFilter5 performs a merge with any union data inside the DateTimeFieldFilter, using the provided DateTimeFieldFilter5
func (t *DateTimeFieldFilter) MergeDateTimeFieldFilter5(v DateTimeFieldFilter5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DateTimeFieldFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DateTimeFieldFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvalidParameterStandard returns the union data inside the InvalidParameters_Item as a InvalidParameterStandard
func (t InvalidParameters_Item) AsInvalidParameterStandard() (InvalidParameterStandard, error) {
	var body InvalidParameterStandard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidParameterStandard overwrites any union data inside the InvalidParameters_Item as the provided InvalidParameterStandard
func (t *InvalidParameters_Item) FromInvalidParameterStandard(v InvalidParameterStandard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidParameterStandard performs a merge with any union data inside the InvalidParameters_Item, using the provided InvalidParameterStandard
func (t *InvalidParameters_Item) MergeInvalidParameterStandard(v InvalidParameterStandard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidParameterMinimumLength returns the union data inside the InvalidParameters_Item as a InvalidParameterMinimumLength
func (t InvalidParameters_Item) AsInvalidParameterMinimumLength() (InvalidParameterMinimumLength, error) {
	var body InvalidParameterMinimumLength
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidParameterMinimumLength overwrites any union data inside the InvalidParameters_Item as the provided InvalidParameterMinimumLength
func (t *InvalidParameters_Item) FromInvalidParameterMinimumLength(v InvalidParameterMinimumLength) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidParameterMinimumLength performs a merge with any union data inside the InvalidParameters_Item, using the provided InvalidParameterMinimumLength
func (t *InvalidParameters_Item) MergeInvalidParameterMinimumLength(v InvalidParameterMinimumLength) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidParameterMaximumLength returns the union data inside the InvalidParameters_Item as a InvalidParameterMaximumLength
func (t InvalidParameters_Item) AsInvalidParameterMaximumLength() (InvalidParameterMaximumLength, error) {
	var body InvalidParameterMaximumLength
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidParameterMaximumLength overwrites any union data inside the InvalidParameters_Item as the provided InvalidParameterMaximumLength
func (t *InvalidParameters_Item) FromInvalidParameterMaximumLength(v InvalidParameterMaximumLength) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidParameterMaximumLength performs a merge with any union data inside the InvalidParameters_Item, using the provided InvalidParameterMaximumLength
func (t *InvalidParameters_Item) MergeInvalidParameterMaximumLength(v InvalidParameterMaximumLength) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidParameterChoiceItem returns the union data inside the InvalidParameters_Item as a InvalidParameterChoiceItem
func (t InvalidParameters_Item) AsInvalidParameterChoiceItem() (InvalidParameterChoiceItem, error) {
	var body InvalidParameterChoiceItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidParameterChoiceItem overwrites any union data inside the InvalidParameters_Item as the provided InvalidParameterChoiceItem
func (t *InvalidParameters_Item) FromInvalidParameterChoiceItem(v InvalidParameterChoiceItem) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidParameterChoiceItem performs a merge with any union data inside the InvalidParameters_Item, using the provided InvalidParameterChoiceItem
func (t *InvalidParameters_Item) MergeInvalidParameterChoiceItem(v InvalidParameterChoiceItem) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidParameterDependentItem returns the union data inside the InvalidParameters_Item as a InvalidParameterDependentItem
func (t InvalidParameters_Item) AsInvalidParameterDependentItem() (InvalidParameterDependentItem, error) {
	var body InvalidParameterDependentItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidParameterDependentItem overwrites any union data inside the InvalidParameters_Item as the provided InvalidParameterDependentItem
func (t *InvalidParameters_Item) FromInvalidParameterDependentItem(v InvalidParameterDependentItem) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidParameterDependentItem performs a merge with any union data inside the InvalidParameters_Item, using the provided InvalidParameterDependentItem
func (t *InvalidParameters_Item) MergeInvalidParameterDependentItem(v InvalidParameterDependentItem) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InvalidParameters_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InvalidParameters_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPortalAuthStrategyKeyAuth returns the union data inside the PortalAuthStrategy as a PortalAuthStrategyKeyAuth
func (t PortalAuthStrategy) AsPortalAuthStrategyKeyAuth() (PortalAuthStrategyKeyAuth, error) {
	var body PortalAuthStrategyKeyAuth
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPortalAuthStrategyKeyAuth overwrites any union data inside the PortalAuthStrategy as the provided PortalAuthStrategyKeyAuth
func (t *PortalAuthStrategy) FromPortalAuthStrategyKeyAuth(v PortalAuthStrategyKeyAuth) error {
	v.CredentialType = "PortalAuthStrategyKeyAuth"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePortalAuthStrategyKeyAuth performs a merge with any union data inside the PortalAuthStrategy, using the provided PortalAuthStrategyKeyAuth
func (t *PortalAuthStrategy) MergePortalAuthStrategyKeyAuth(v PortalAuthStrategyKeyAuth) error {
	v.CredentialType = "PortalAuthStrategyKeyAuth"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPortalAuthStrategyClientCredentials returns the union data inside the PortalAuthStrategy as a PortalAuthStrategyClientCredentials
func (t PortalAuthStrategy) AsPortalAuthStrategyClientCredentials() (PortalAuthStrategyClientCredentials, error) {
	var body PortalAuthStrategyClientCredentials
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPortalAuthStrategyClientCredentials overwrites any union data inside the PortalAuthStrategy as the provided PortalAuthStrategyClientCredentials
func (t *PortalAuthStrategy) FromPortalAuthStrategyClientCredentials(v PortalAuthStrategyClientCredentials) error {
	v.CredentialType = "PortalAuthStrategyClientCredentials"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePortalAuthStrategyClientCredentials performs a merge with any union data inside the PortalAuthStrategy, using the provided PortalAuthStrategyClientCredentials
func (t *PortalAuthStrategy) MergePortalAuthStrategyClientCredentials(v PortalAuthStrategyClientCredentials) error {
	v.CredentialType = "PortalAuthStrategyClientCredentials"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PortalAuthStrategy) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"credential_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PortalAuthStrategy) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "PortalAuthStrategyClientCredentials":
		return t.AsPortalAuthStrategyClientCredentials()
	case "PortalAuthStrategyKeyAuth":
		return t.AsPortalAuthStrategyKeyAuth()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PortalAuthStrategy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PortalAuthStrategy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPortalSearchResultOperation returns the union data inside the PortalSearchResults_Data_Item as a PortalSearchResultOperation
func (t PortalSearchResults_Data_Item) AsPortalSearchResultOperation() (PortalSearchResultOperation, error) {
	var body PortalSearchResultOperation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPortalSearchResultOperation overwrites any union data inside the PortalSearchResults_Data_Item as the provided PortalSearchResultOperation
func (t *PortalSearchResults_Data_Item) FromPortalSearchResultOperation(v PortalSearchResultOperation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePortalSearchResultOperation performs a merge with any union data inside the PortalSearchResults_Data_Item, using the provided PortalSearchResultOperation
func (t *PortalSearchResults_Data_Item) MergePortalSearchResultOperation(v PortalSearchResultOperation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPortalSearchResultDocument returns the union data inside the PortalSearchResults_Data_Item as a PortalSearchResultDocument
func (t PortalSearchResults_Data_Item) AsPortalSearchResultDocument() (PortalSearchResultDocument, error) {
	var body PortalSearchResultDocument
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPortalSearchResultDocument overwrites any union data inside the PortalSearchResults_Data_Item as the provided PortalSearchResultDocument
func (t *PortalSearchResults_Data_Item) FromPortalSearchResultDocument(v PortalSearchResultDocument) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePortalSearchResultDocument performs a merge with any union data inside the PortalSearchResults_Data_Item, using the provided PortalSearchResultDocument
func (t *PortalSearchResults_Data_Item) MergePortalSearchResultDocument(v PortalSearchResultDocument) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PortalSearchResults_Data_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PortalSearchResults_Data_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsApiFilter returns the union data inside the QueryApplicationAnalytics_Filters_Item as a ApiFilter
func (t QueryApplicationAnalytics_Filters_Item) AsApiFilter() (ApiFilter, error) {
	var body ApiFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiFilter overwrites any union data inside the QueryApplicationAnalytics_Filters_Item as the provided ApiFilter
func (t *QueryApplicationAnalytics_Filters_Item) FromApiFilter(v ApiFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiFilter performs a merge with any union data inside the QueryApplicationAnalytics_Filters_Item, using the provided ApiFilter
func (t *QueryApplicationAnalytics_Filters_Item) MergeApiFilter(v ApiFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsApplicationFilter returns the union data inside the QueryApplicationAnalytics_Filters_Item as a ApplicationFilter
func (t QueryApplicationAnalytics_Filters_Item) AsApplicationFilter() (ApplicationFilter, error) {
	var body ApplicationFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApplicationFilter overwrites any union data inside the QueryApplicationAnalytics_Filters_Item as the provided ApplicationFilter
func (t *QueryApplicationAnalytics_Filters_Item) FromApplicationFilter(v ApplicationFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApplicationFilter performs a merge with any union data inside the QueryApplicationAnalytics_Filters_Item, using the provided ApplicationFilter
func (t *QueryApplicationAnalytics_Filters_Item) MergeApplicationFilter(v ApplicationFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusCodeFilter returns the union data inside the QueryApplicationAnalytics_Filters_Item as a StatusCodeFilter
func (t QueryApplicationAnalytics_Filters_Item) AsStatusCodeFilter() (StatusCodeFilter, error) {
	var body StatusCodeFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusCodeFilter overwrites any union data inside the QueryApplicationAnalytics_Filters_Item as the provided StatusCodeFilter
func (t *QueryApplicationAnalytics_Filters_Item) FromStatusCodeFilter(v StatusCodeFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusCodeFilter performs a merge with any union data inside the QueryApplicationAnalytics_Filters_Item, using the provided StatusCodeFilter
func (t *QueryApplicationAnalytics_Filters_Item) MergeStatusCodeFilter(v StatusCodeFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusCodeGroupedFilter returns the union data inside the QueryApplicationAnalytics_Filters_Item as a StatusCodeGroupedFilter
func (t QueryApplicationAnalytics_Filters_Item) AsStatusCodeGroupedFilter() (StatusCodeGroupedFilter, error) {
	var body StatusCodeGroupedFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusCodeGroupedFilter overwrites any union data inside the QueryApplicationAnalytics_Filters_Item as the provided StatusCodeGroupedFilter
func (t *QueryApplicationAnalytics_Filters_Item) FromStatusCodeGroupedFilter(v StatusCodeGroupedFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusCodeGroupedFilter performs a merge with any union data inside the QueryApplicationAnalytics_Filters_Item, using the provided StatusCodeGroupedFilter
func (t *QueryApplicationAnalytics_Filters_Item) MergeStatusCodeGroupedFilter(v StatusCodeGroupedFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t QueryApplicationAnalytics_Filters_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *QueryApplicationAnalytics_Filters_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelativeTimeRangeDto returns the union data inside the QueryApplicationAnalytics_TimeRange as a RelativeTimeRangeDto
func (t QueryApplicationAnalytics_TimeRange) AsRelativeTimeRangeDto() (RelativeTimeRangeDto, error) {
	var body RelativeTimeRangeDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelativeTimeRangeDto overwrites any union data inside the QueryApplicationAnalytics_TimeRange as the provided RelativeTimeRangeDto
func (t *QueryApplicationAnalytics_TimeRange) FromRelativeTimeRangeDto(v RelativeTimeRangeDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelativeTimeRangeDto performs a merge with any union data inside the QueryApplicationAnalytics_TimeRange, using the provided RelativeTimeRangeDto
func (t *QueryApplicationAnalytics_TimeRange) MergeRelativeTimeRangeDto(v RelativeTimeRangeDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAbsoluteTimeRangeDto returns the union data inside the QueryApplicationAnalytics_TimeRange as a AbsoluteTimeRangeDto
func (t QueryApplicationAnalytics_TimeRange) AsAbsoluteTimeRangeDto() (AbsoluteTimeRangeDto, error) {
	var body AbsoluteTimeRangeDto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbsoluteTimeRangeDto overwrites any union data inside the QueryApplicationAnalytics_TimeRange as the provided AbsoluteTimeRangeDto
func (t *QueryApplicationAnalytics_TimeRange) FromAbsoluteTimeRangeDto(v AbsoluteTimeRangeDto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbsoluteTimeRangeDto performs a merge with any union data inside the QueryApplicationAnalytics_TimeRange, using the provided AbsoluteTimeRangeDto
func (t *QueryApplicationAnalytics_TimeRange) MergeAbsoluteTimeRangeDto(v AbsoluteTimeRangeDto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t QueryApplicationAnalytics_TimeRange) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *QueryApplicationAnalytics_TimeRange) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStringFieldEqualsFilter0 returns the union data inside the StringFieldEqualsFilter as a StringFieldEqualsFilter0
func (t StringFieldEqualsFilter) AsStringFieldEqualsFilter0() (StringFieldEqualsFilter0, error) {
	var body StringFieldEqualsFilter0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldEqualsFilter0 overwrites any union data inside the StringFieldEqualsFilter as the provided StringFieldEqualsFilter0
func (t *StringFieldEqualsFilter) FromStringFieldEqualsFilter0(v StringFieldEqualsFilter0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldEqualsFilter0 performs a merge with any union data inside the StringFieldEqualsFilter, using the provided StringFieldEqualsFilter0
func (t *StringFieldEqualsFilter) MergeStringFieldEqualsFilter0(v StringFieldEqualsFilter0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldEqualsFilter1 returns the union data inside the StringFieldEqualsFilter as a StringFieldEqualsFilter1
func (t StringFieldEqualsFilter) AsStringFieldEqualsFilter1() (StringFieldEqualsFilter1, error) {
	var body StringFieldEqualsFilter1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldEqualsFilter1 overwrites any union data inside the StringFieldEqualsFilter as the provided StringFieldEqualsFilter1
func (t *StringFieldEqualsFilter) FromStringFieldEqualsFilter1(v StringFieldEqualsFilter1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldEqualsFilter1 performs a merge with any union data inside the StringFieldEqualsFilter, using the provided StringFieldEqualsFilter1
func (t *StringFieldEqualsFilter) MergeStringFieldEqualsFilter1(v StringFieldEqualsFilter1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StringFieldEqualsFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StringFieldEqualsFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStringFieldEqualsFilter returns the union data inside the StringFieldFilter as a StringFieldEqualsFilter
func (t StringFieldFilter) AsStringFieldEqualsFilter() (StringFieldEqualsFilter, error) {
	var body StringFieldEqualsFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldEqualsFilter overwrites any union data inside the StringFieldFilter as the provided StringFieldEqualsFilter
func (t *StringFieldFilter) FromStringFieldEqualsFilter(v StringFieldEqualsFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldEqualsFilter performs a merge with any union data inside the StringFieldFilter, using the provided StringFieldEqualsFilter
func (t *StringFieldFilter) MergeStringFieldEqualsFilter(v StringFieldEqualsFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldContainsFilter returns the union data inside the StringFieldFilter as a StringFieldContainsFilter
func (t StringFieldFilter) AsStringFieldContainsFilter() (StringFieldContainsFilter, error) {
	var body StringFieldContainsFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldContainsFilter overwrites any union data inside the StringFieldFilter as the provided StringFieldContainsFilter
func (t *StringFieldFilter) FromStringFieldContainsFilter(v StringFieldContainsFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldContainsFilter performs a merge with any union data inside the StringFieldFilter, using the provided StringFieldContainsFilter
func (t *StringFieldFilter) MergeStringFieldContainsFilter(v StringFieldContainsFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldOContainsFilter returns the union data inside the StringFieldFilter as a StringFieldOContainsFilter
func (t StringFieldFilter) AsStringFieldOContainsFilter() (StringFieldOContainsFilter, error) {
	var body StringFieldOContainsFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldOContainsFilter overwrites any union data inside the StringFieldFilter as the provided StringFieldOContainsFilter
func (t *StringFieldFilter) FromStringFieldOContainsFilter(v StringFieldOContainsFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldOContainsFilter performs a merge with any union data inside the StringFieldFilter, using the provided StringFieldOContainsFilter
func (t *StringFieldFilter) MergeStringFieldOContainsFilter(v StringFieldOContainsFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldOEQFilter returns the union data inside the StringFieldFilter as a StringFieldOEQFilter
func (t StringFieldFilter) AsStringFieldOEQFilter() (StringFieldOEQFilter, error) {
	var body StringFieldOEQFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldOEQFilter overwrites any union data inside the StringFieldFilter as the provided StringFieldOEQFilter
func (t *StringFieldFilter) FromStringFieldOEQFilter(v StringFieldOEQFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldOEQFilter performs a merge with any union data inside the StringFieldFilter, using the provided StringFieldOEQFilter
func (t *StringFieldFilter) MergeStringFieldOEQFilter(v StringFieldOEQFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldNEQFilter returns the union data inside the StringFieldFilter as a StringFieldNEQFilter
func (t StringFieldFilter) AsStringFieldNEQFilter() (StringFieldNEQFilter, error) {
	var body StringFieldNEQFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldNEQFilter overwrites any union data inside the StringFieldFilter as the provided StringFieldNEQFilter
func (t *StringFieldFilter) FromStringFieldNEQFilter(v StringFieldNEQFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldNEQFilter performs a merge with any union data inside the StringFieldFilter, using the provided StringFieldNEQFilter
func (t *StringFieldFilter) MergeStringFieldNEQFilter(v StringFieldNEQFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StringFieldFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StringFieldFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStringFieldEqualsFilter returns the union data inside the UuidFieldFilter as a StringFieldEqualsFilter
func (t UuidFieldFilter) AsStringFieldEqualsFilter() (StringFieldEqualsFilter, error) {
	var body StringFieldEqualsFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldEqualsFilter overwrites any union data inside the UuidFieldFilter as the provided StringFieldEqualsFilter
func (t *UuidFieldFilter) FromStringFieldEqualsFilter(v StringFieldEqualsFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldEqualsFilter performs a merge with any union data inside the UuidFieldFilter, using the provided StringFieldEqualsFilter
func (t *UuidFieldFilter) MergeStringFieldEqualsFilter(v StringFieldEqualsFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldOEQFilter returns the union data inside the UuidFieldFilter as a StringFieldOEQFilter
func (t UuidFieldFilter) AsStringFieldOEQFilter() (StringFieldOEQFilter, error) {
	var body StringFieldOEQFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldOEQFilter overwrites any union data inside the UuidFieldFilter as the provided StringFieldOEQFilter
func (t *UuidFieldFilter) FromStringFieldOEQFilter(v StringFieldOEQFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldOEQFilter performs a merge with any union data inside the UuidFieldFilter, using the provided StringFieldOEQFilter
func (t *UuidFieldFilter) MergeStringFieldOEQFilter(v StringFieldOEQFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringFieldNEQFilter returns the union data inside the UuidFieldFilter as a StringFieldNEQFilter
func (t UuidFieldFilter) AsStringFieldNEQFilter() (StringFieldNEQFilter, error) {
	var body StringFieldNEQFilter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringFieldNEQFilter overwrites any union data inside the UuidFieldFilter as the provided StringFieldNEQFilter
func (t *UuidFieldFilter) FromStringFieldNEQFilter(v StringFieldNEQFilter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringFieldNEQFilter performs a merge with any union data inside the UuidFieldFilter, using the provided StringFieldNEQFilter
func (t *UuidFieldFilter) MergeStringFieldNEQFilter(v StringFieldNEQFilter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UuidFieldFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UuidFieldFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsApiId returns the union data inside the ApiIdOrSlug as a ApiId
func (t ApiIdOrSlug) AsApiId() (ApiId, error) {
	var body ApiId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiId overwrites any union data inside the ApiIdOrSlug as the provided ApiId
func (t *ApiIdOrSlug) FromApiId(v ApiId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiId performs a merge with any union data inside the ApiIdOrSlug, using the provided ApiId
func (t *ApiIdOrSlug) MergeApiId(v ApiId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsApiSlug returns the union data inside the ApiIdOrSlug as a ApiSlug
func (t ApiIdOrSlug) AsApiSlug() (ApiSlug, error) {
	var body ApiSlug
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiSlug overwrites any union data inside the ApiIdOrSlug as the provided ApiSlug
func (t *ApiIdOrSlug) FromApiSlug(v ApiSlug) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiSlug performs a merge with any union data inside the ApiIdOrSlug, using the provided ApiSlug
func (t *ApiIdOrSlug) MergeApiSlug(v ApiSlug) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiIdOrSlug) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiIdOrSlug) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDocumentId returns the union data inside the DocumentIdOrSlug as a DocumentId
func (t DocumentIdOrSlug) AsDocumentId() (DocumentId, error) {
	var body DocumentId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentId overwrites any union data inside the DocumentIdOrSlug as the provided DocumentId
func (t *DocumentIdOrSlug) FromDocumentId(v DocumentId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentId performs a merge with any union data inside the DocumentIdOrSlug, using the provided DocumentId
func (t *DocumentIdOrSlug) MergeDocumentId(v DocumentId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDocumentSlug returns the union data inside the DocumentIdOrSlug as a DocumentSlug
func (t DocumentIdOrSlug) AsDocumentSlug() (DocumentSlug, error) {
	var body DocumentSlug
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentSlug overwrites any union data inside the DocumentIdOrSlug as the provided DocumentSlug
func (t *DocumentIdOrSlug) FromDocumentSlug(v DocumentSlug) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentSlug performs a merge with any union data inside the DocumentIdOrSlug, using the provided DocumentSlug
func (t *DocumentIdOrSlug) MergeDocumentSlug(v DocumentSlug) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DocumentIdOrSlug) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DocumentIdOrSlug) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetPaginatedApiAttributes request
	GetPaginatedApiAttributes(ctx context.Context, params *GetPaginatedApiAttributesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApis request
	ListApis(ctx context.Context, params *ListApisParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchApi request
	FetchApi(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiActions request
	GetApiActions(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiApplications request
	GetApiApplications(ctx context.Context, apiIdOrSlug ApiIdOrSlug, params *GetApiApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApiDocuments request
	ListApiDocuments(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchApiDocument request
	FetchApiDocument(ctx context.Context, apiIdOrSlug ApiIdOrSlug, documentIdOrSlug DocumentIdOrSlug, params *FetchApiDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApiSpecs request
	ListApiSpecs(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchApiSpec request
	FetchApiSpec(ctx context.Context, apiIdOrSlug ApiIdOrSlug, specId SpecId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchApiSpecRaw request
	FetchApiSpecRaw(ctx context.Context, apiIdOrSlug ApiIdOrSlug, specId SpecId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApiVersionSpecs request
	ListApiVersionSpecs(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchApiVersionSpec request
	FetchApiVersionSpec(ctx context.Context, apiIdOrSlug ApiIdOrSlug, versionId VersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchApiVersionSpecRaw request
	FetchApiVersionSpecRaw(ctx context.Context, apiIdOrSlug ApiIdOrSlug, versionId VersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApplicationAuthStrategies request
	ListApplicationAuthStrategies(ctx context.Context, params *ListApplicationAuthStrategiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApplications request
	ListApplications(ctx context.Context, params *ListApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApplicationWithBody request with any body
	CreateApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApplication(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApplication request
	DeleteApplication(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplication request
	GetApplication(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateApplicationWithBody request with any body
	UpdateApplicationWithBody(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApplication(ctx context.Context, applicationId ApplicationId, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCredentials request
	ListCredentials(ctx context.Context, applicationId ApplicationId, params *ListCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCredentialWithBody request with any body
	CreateCredentialWithBody(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCredential(ctx context.Context, applicationId ApplicationId, body CreateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCredential request
	DeleteCredential(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCredentialWithBody request with any body
	UpdateCredentialWithBody(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCredential(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, body UpdateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationGrantedScopes request
	GetApplicationGrantedScopes(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegenerateApplicationSecret request
	RegenerateApplicationSecret(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApplicationRegistrations request
	ListApplicationRegistrations(ctx context.Context, applicationId ApplicationId, params *ListApplicationRegistrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApplicationRegistrationWithBody request with any body
	CreateApplicationRegistrationWithBody(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApplicationRegistration(ctx context.Context, applicationId ApplicationId, body CreateApplicationRegistrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApplicationRegistration request
	DeleteApplicationRegistration(ctx context.Context, applicationId ApplicationId, registrationId RegistrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationRegistration request
	GetApplicationRegistration(ctx context.Context, applicationId ApplicationId, registrationId RegistrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPortalFavicon request
	GetPortalFavicon(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPortalLogo request
	GetPortalLogo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPortalCustomization request
	GetPortalCustomization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterWithBody request with any body
	RegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Register(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticateWithBody request with any body
	AuthenticateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Authenticate(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticateSso request
	AuthenticateSso(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ForgotPasswordWithBody request with any body
	ForgotPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForgotPassword(ctx context.Context, body ForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeveloperMe request
	GetDeveloperMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Refresh request
	Refresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPasswordWithBody request with any body
	ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyEmailWithBody request with any body
	VerifyEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VerifyEmail(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPortalPages request
	ListPortalPages(ctx context.Context, params *ListPortalPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPortalPageByName request
	GetPortalPageByName(ctx context.Context, pagePath PagePath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPortalContext request
	GetPortalContext(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPortal request
	SearchPortal(ctx context.Context, params *SearchPortalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPortalSnippets request
	ListPortalSnippets(ctx context.Context, params *ListPortalSnippetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPortalSnippetByName request
	GetPortalSnippetByName(ctx context.Context, snippetNameParam SnippetNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryApplicationAnalyticsWithBody request with any body
	QueryApplicationAnalyticsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryApplicationAnalytics(ctx context.Context, body QueryApplicationAnalyticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationAnalyticsConfig request
	GetApplicationAnalyticsConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetPaginatedApiAttributes(ctx context.Context, params *GetPaginatedApiAttributesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaginatedApiAttributesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApis(ctx context.Context, params *ListApisParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApisRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchApi(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchApiRequest(c.Server, apiIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiActions(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiActionsRequest(c.Server, apiIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiApplications(ctx context.Context, apiIdOrSlug ApiIdOrSlug, params *GetApiApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiApplicationsRequest(c.Server, apiIdOrSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApiDocuments(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiDocumentsRequest(c.Server, apiIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchApiDocument(ctx context.Context, apiIdOrSlug ApiIdOrSlug, documentIdOrSlug DocumentIdOrSlug, params *FetchApiDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchApiDocumentRequest(c.Server, apiIdOrSlug, documentIdOrSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApiSpecs(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiSpecsRequest(c.Server, apiIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchApiSpec(ctx context.Context, apiIdOrSlug ApiIdOrSlug, specId SpecId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchApiSpecRequest(c.Server, apiIdOrSlug, specId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchApiSpecRaw(ctx context.Context, apiIdOrSlug ApiIdOrSlug, specId SpecId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchApiSpecRawRequest(c.Server, apiIdOrSlug, specId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApiVersionSpecs(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiVersionSpecsRequest(c.Server, apiIdOrSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchApiVersionSpec(ctx context.Context, apiIdOrSlug ApiIdOrSlug, versionId VersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchApiVersionSpecRequest(c.Server, apiIdOrSlug, versionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchApiVersionSpecRaw(ctx context.Context, apiIdOrSlug ApiIdOrSlug, versionId VersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchApiVersionSpecRawRequest(c.Server, apiIdOrSlug, versionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApplicationAuthStrategies(ctx context.Context, params *ListApplicationAuthStrategiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApplicationAuthStrategiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApplications(ctx context.Context, params *ListApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApplicationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplication(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApplication(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApplicationRequest(c.Server, applicationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplication(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationRequest(c.Server, applicationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApplicationWithBody(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApplicationRequestWithBody(c.Server, applicationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApplication(ctx context.Context, applicationId ApplicationId, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApplicationRequest(c.Server, applicationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCredentials(ctx context.Context, applicationId ApplicationId, params *ListCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCredentialsRequest(c.Server, applicationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCredentialWithBody(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCredentialRequestWithBody(c.Server, applicationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCredential(ctx context.Context, applicationId ApplicationId, body CreateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCredentialRequest(c.Server, applicationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCredential(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCredentialRequest(c.Server, applicationId, credentialId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCredentialWithBody(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCredentialRequestWithBody(c.Server, applicationId, credentialId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCredential(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, body UpdateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCredentialRequest(c.Server, applicationId, credentialId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplicationGrantedScopes(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationGrantedScopesRequest(c.Server, applicationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenerateApplicationSecret(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenerateApplicationSecretRequest(c.Server, applicationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApplicationRegistrations(ctx context.Context, applicationId ApplicationId, params *ListApplicationRegistrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApplicationRegistrationsRequest(c.Server, applicationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplicationRegistrationWithBody(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRegistrationRequestWithBody(c.Server, applicationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplicationRegistration(ctx context.Context, applicationId ApplicationId, body CreateApplicationRegistrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRegistrationRequest(c.Server, applicationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApplicationRegistration(ctx context.Context, applicationId ApplicationId, registrationId RegistrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApplicationRegistrationRequest(c.Server, applicationId, registrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplicationRegistration(ctx context.Context, applicationId ApplicationId, registrationId RegistrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationRegistrationRequest(c.Server, applicationId, registrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPortalFavicon(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPortalFaviconRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPortalLogo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPortalLogoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPortalCustomization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPortalCustomizationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Register(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Authenticate(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateSso(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateSsoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForgotPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForgotPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForgotPassword(ctx context.Context, body ForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForgotPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeveloperMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeveloperMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Refresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyEmail(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPortalPages(ctx context.Context, params *ListPortalPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPortalPagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPortalPageByName(ctx context.Context, pagePath PagePath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPortalPageByNameRequest(c.Server, pagePath)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPortalContext(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPortalContextRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPortal(ctx context.Context, params *SearchPortalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPortalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPortalSnippets(ctx context.Context, params *ListPortalSnippetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPortalSnippetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPortalSnippetByName(ctx context.Context, snippetNameParam SnippetNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPortalSnippetByNameRequest(c.Server, snippetNameParam)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryApplicationAnalyticsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryApplicationAnalyticsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryApplicationAnalytics(ctx context.Context, body QueryApplicationAnalyticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryApplicationAnalyticsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplicationAnalyticsConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationAnalyticsConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetPaginatedApiAttributesRequest generates requests for GetPaginatedApiAttributes
func NewGetPaginatedApiAttributesRequest(server string, params *GetPaginatedApiAttributesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/api-attributes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Selected != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "selected", runtime.ParamLocationQuery, *params.Selected); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApisRequest generates requests for ListApis
func NewListApisRequest(server string, params *ListApisParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[number]", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchApiRequest generates requests for FetchApi
func NewFetchApiRequest(server string, apiIdOrSlug ApiIdOrSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiActionsRequest generates requests for GetApiActions
func NewGetApiActionsRequest(server string, apiIdOrSlug ApiIdOrSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiApplicationsRequest generates requests for GetApiApplications
func NewGetApiApplicationsRequest(server string, apiIdOrSlug ApiIdOrSlug, params *GetApiApplicationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s/applications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Unregistered != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unregistered", runtime.ParamLocationQuery, *params.Unregistered); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Applicationfilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "applicationfilter", runtime.ParamLocationQuery, *params.Applicationfilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[number]", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApiDocumentsRequest generates requests for ListApiDocuments
func NewListApiDocumentsRequest(server string, apiIdOrSlug ApiIdOrSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s/documents", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchApiDocumentRequest generates requests for FetchApiDocument
func NewFetchApiDocumentRequest(server string, apiIdOrSlug ApiIdOrSlug, documentIdOrSlug DocumentIdOrSlug, params *FetchApiDocumentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "documentIdOrSlug", runtime.ParamLocationPath, documentIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s/documents/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewListApiSpecsRequest generates requests for ListApiSpecs
func NewListApiSpecsRequest(server string, apiIdOrSlug ApiIdOrSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s/specifications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchApiSpecRequest generates requests for FetchApiSpec
func NewFetchApiSpecRequest(server string, apiIdOrSlug ApiIdOrSlug, specId SpecId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "specId", runtime.ParamLocationPath, specId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s/specifications/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchApiSpecRawRequest generates requests for FetchApiSpecRaw
func NewFetchApiSpecRawRequest(server string, apiIdOrSlug ApiIdOrSlug, specId SpecId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "specId", runtime.ParamLocationPath, specId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s/specifications/%s/raw", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApiVersionSpecsRequest generates requests for ListApiVersionSpecs
func NewListApiVersionSpecsRequest(server string, apiIdOrSlug ApiIdOrSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchApiVersionSpecRequest generates requests for FetchApiVersionSpec
func NewFetchApiVersionSpecRequest(server string, apiIdOrSlug ApiIdOrSlug, versionId VersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "versionId", runtime.ParamLocationPath, versionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchApiVersionSpecRawRequest generates requests for FetchApiVersionSpecRaw
func NewFetchApiVersionSpecRawRequest(server string, apiIdOrSlug ApiIdOrSlug, versionId VersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apiIdOrSlug", runtime.ParamLocationPath, apiIdOrSlug)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "versionId", runtime.ParamLocationPath, versionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/apis/%s/versions/%s/raw", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApplicationAuthStrategiesRequest generates requests for ListApplicationAuthStrategies
func NewListApplicationAuthStrategiesRequest(server string, params *ListApplicationAuthStrategiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/application-auth-strategies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[number]", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterNameEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[name][eq]", runtime.ParamLocationQuery, *params.FilterNameEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[name]", runtime.ParamLocationQuery, *params.FilterName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterNameContains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[name][contains]", runtime.ParamLocationQuery, *params.FilterNameContains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterCredentialTypeEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[credential_type][eq]", runtime.ParamLocationQuery, *params.FilterCredentialTypeEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApplicationsRequest generates requests for ListApplications
func NewListApplicationsRequest(server string, params *ListApplicationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[number]", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterNameEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[name][eq]", runtime.ParamLocationQuery, *params.FilterNameEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[name]", runtime.ParamLocationQuery, *params.FilterName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterNameContains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[name][contains]", runtime.ParamLocationQuery, *params.FilterNameContains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterAuthStrategyIdEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[auth_strategy_id][eq]", runtime.ParamLocationQuery, *params.FilterAuthStrategyIdEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterAuthStrategyId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[auth_strategy_id]", runtime.ParamLocationQuery, *params.FilterAuthStrategyId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApplicationRequest calls the generic CreateApplication builder with application/json body
func NewCreateApplicationRequest(server string, body CreateApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateApplicationRequestWithBody generates requests for CreateApplication with any type of body
func NewCreateApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApplicationRequest generates requests for DeleteApplication
func NewDeleteApplicationRequest(server string, applicationId ApplicationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationRequest generates requests for GetApplication
func NewGetApplicationRequest(server string, applicationId ApplicationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateApplicationRequest calls the generic UpdateApplication builder with application/json body
func NewUpdateApplicationRequest(server string, applicationId ApplicationId, body UpdateApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateApplicationRequestWithBody(server, applicationId, "application/json", bodyReader)
}

// NewUpdateApplicationRequestWithBody generates requests for UpdateApplication with any type of body
func NewUpdateApplicationRequestWithBody(server string, applicationId ApplicationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCredentialsRequest generates requests for ListCredentials
func NewListCredentialsRequest(server string, applicationId ApplicationId, params *ListCredentialsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[number]", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCredentialRequest calls the generic CreateCredential builder with application/json body
func NewCreateCredentialRequest(server string, applicationId ApplicationId, body CreateCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCredentialRequestWithBody(server, applicationId, "application/json", bodyReader)
}

// NewCreateCredentialRequestWithBody generates requests for CreateCredential with any type of body
func NewCreateCredentialRequestWithBody(server string, applicationId ApplicationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCredentialRequest generates requests for DeleteCredential
func NewDeleteCredentialRequest(server string, applicationId ApplicationId, credentialId CredentialId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "credentialId", runtime.ParamLocationPath, credentialId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCredentialRequest calls the generic UpdateCredential builder with application/json body
func NewUpdateCredentialRequest(server string, applicationId ApplicationId, credentialId CredentialId, body UpdateCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCredentialRequestWithBody(server, applicationId, credentialId, "application/json", bodyReader)
}

// NewUpdateCredentialRequestWithBody generates requests for UpdateCredential with any type of body
func NewUpdateCredentialRequestWithBody(server string, applicationId ApplicationId, credentialId CredentialId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "credentialId", runtime.ParamLocationPath, credentialId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetApplicationGrantedScopesRequest generates requests for GetApplicationGrantedScopes
func NewGetApplicationGrantedScopesRequest(server string, applicationId ApplicationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s/granted-scopes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegenerateApplicationSecretRequest generates requests for RegenerateApplicationSecret
func NewRegenerateApplicationSecretRequest(server string, applicationId ApplicationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s/regenerate-secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApplicationRegistrationsRequest generates requests for ListApplicationRegistrations
func NewListApplicationRegistrationsRequest(server string, applicationId ApplicationId, params *ListApplicationRegistrationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s/registrations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[number]", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterIdEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[id][eq]", runtime.ParamLocationQuery, *params.FilterIdEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[id]", runtime.ParamLocationQuery, *params.FilterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterStatusEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[status][eq]", runtime.ParamLocationQuery, *params.FilterStatusEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[status]", runtime.ParamLocationQuery, *params.FilterStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterApiNameEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[api_name][eq]", runtime.ParamLocationQuery, *params.FilterApiNameEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterApiName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[api_name]", runtime.ParamLocationQuery, *params.FilterApiName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterApiNameContains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[api_name][contains]", runtime.ParamLocationQuery, *params.FilterApiNameContains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApplicationRegistrationRequest calls the generic CreateApplicationRegistration builder with application/json body
func NewCreateApplicationRegistrationRequest(server string, applicationId ApplicationId, body CreateApplicationRegistrationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApplicationRegistrationRequestWithBody(server, applicationId, "application/json", bodyReader)
}

// NewCreateApplicationRegistrationRequestWithBody generates requests for CreateApplicationRegistration with any type of body
func NewCreateApplicationRegistrationRequestWithBody(server string, applicationId ApplicationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s/registrations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApplicationRegistrationRequest generates requests for DeleteApplicationRegistration
func NewDeleteApplicationRegistrationRequest(server string, applicationId ApplicationId, registrationId RegistrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "registrationId", runtime.ParamLocationPath, registrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s/registrations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationRegistrationRequest generates requests for GetApplicationRegistration
func NewGetApplicationRegistrationRequest(server string, applicationId ApplicationId, registrationId RegistrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationId", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "registrationId", runtime.ParamLocationPath, registrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/applications/%s/registrations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPortalFaviconRequest generates requests for GetPortalFavicon
func NewGetPortalFaviconRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/assets/favicon")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPortalLogoRequest generates requests for GetPortalLogo
func NewGetPortalLogoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/assets/logo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPortalCustomizationRequest generates requests for GetPortalCustomization
func NewGetPortalCustomizationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/customization")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterRequest calls the generic Register builder with application/json body
func NewRegisterRequest(server string, body RegisterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterRequestWithBody generates requests for Register with any type of body
func NewRegisterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/developer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthenticateRequest calls the generic Authenticate builder with application/json body
func NewAuthenticateRequest(server string, body AuthenticateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticateRequestWithBody generates requests for Authenticate with any type of body
func NewAuthenticateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/developer/authenticate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthenticateSsoRequest generates requests for AuthenticateSso
func NewAuthenticateSsoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/developer/authenticate/sso")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewForgotPasswordRequest calls the generic ForgotPassword builder with application/json body
func NewForgotPasswordRequest(server string, body ForgotPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForgotPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewForgotPasswordRequestWithBody generates requests for ForgotPassword with any type of body
func NewForgotPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/developer/forgot-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/developer/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeveloperMeRequest generates requests for GetDeveloperMe
func NewGetDeveloperMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/developer/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshRequest generates requests for Refresh
func NewRefreshRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/developer/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetPasswordRequest calls the generic ResetPassword builder with application/json body
func NewResetPasswordRequest(server string, body ResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/developer/reset-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyEmailRequest calls the generic VerifyEmail builder with application/json body
func NewVerifyEmailRequest(server string, body VerifyEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVerifyEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewVerifyEmailRequestWithBody generates requests for VerifyEmail with any type of body
func NewVerifyEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/developer/verify-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPortalPagesRequest generates requests for ListPortalPages
func NewListPortalPagesRequest(server string, params *ListPortalPagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/pages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterTitleEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[title][eq]", runtime.ParamLocationQuery, *params.FilterTitleEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[title]", runtime.ParamLocationQuery, *params.FilterTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterTitleContains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[title][contains]", runtime.ParamLocationQuery, *params.FilterTitleContains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterSlugEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[slug][eq]", runtime.ParamLocationQuery, *params.FilterSlugEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterSlug != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[slug]", runtime.ParamLocationQuery, *params.FilterSlug); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterSlugContains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[slug][contains]", runtime.ParamLocationQuery, *params.FilterSlugContains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterVisibilityEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[visibility][eq]", runtime.ParamLocationQuery, *params.FilterVisibilityEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterVisibility != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[visibility]", runtime.ParamLocationQuery, *params.FilterVisibility); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPortalPageByNameRequest generates requests for GetPortalPageByName
func NewGetPortalPageByNameRequest(server string, pagePath PagePath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pagePath", runtime.ParamLocationPath, pagePath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/pages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPortalContextRequest generates requests for GetPortalContext
func NewGetPortalContextRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/portal")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchPortalRequest generates requests for SearchPortal
func NewSearchPortalRequest(server string, params *SearchPortalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[after]", runtime.ParamLocationQuery, *params.PageAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPortalSnippetsRequest generates requests for ListPortalSnippets
func NewListPortalSnippetsRequest(server string, params *ListPortalSnippetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/snippets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[number]", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterTitleEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[title][eq]", runtime.ParamLocationQuery, *params.FilterTitleEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[title]", runtime.ParamLocationQuery, *params.FilterTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterTitleContains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[title][contains]", runtime.ParamLocationQuery, *params.FilterTitleContains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterNameEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[name][eq]", runtime.ParamLocationQuery, *params.FilterNameEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[name]", runtime.ParamLocationQuery, *params.FilterName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterVisibilityEq != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[visibility][eq]", runtime.ParamLocationQuery, *params.FilterVisibilityEq); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterVisibility != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[visibility]", runtime.ParamLocationQuery, *params.FilterVisibility); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPortalSnippetByNameRequest generates requests for GetPortalSnippetByName
func NewGetPortalSnippetByNameRequest(server string, snippetNameParam SnippetNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "snippetName", runtime.ParamLocationPath, snippetNameParam)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/snippets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryApplicationAnalyticsRequest calls the generic QueryApplicationAnalytics builder with application/json body
func NewQueryApplicationAnalyticsRequest(server string, body QueryApplicationAnalyticsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryApplicationAnalyticsRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryApplicationAnalyticsRequestWithBody generates requests for QueryApplicationAnalytics with any type of body
func NewQueryApplicationAnalyticsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetApplicationAnalyticsConfigRequest generates requests for GetApplicationAnalyticsConfig
func NewGetApplicationAnalyticsConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/stats/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetPaginatedApiAttributesWithResponse request
	GetPaginatedApiAttributesWithResponse(ctx context.Context, params *GetPaginatedApiAttributesParams, reqEditors ...RequestEditorFn) (*GetPaginatedApiAttributesHTTP, error)

	// ListApisWithResponse request
	ListApisWithResponse(ctx context.Context, params *ListApisParams, reqEditors ...RequestEditorFn) (*ListApisHTTP, error)

	// FetchApiWithResponse request
	FetchApiWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*FetchApiHTTP, error)

	// GetApiActionsWithResponse request
	GetApiActionsWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*GetApiActionsHTTP, error)

	// GetApiApplicationsWithResponse request
	GetApiApplicationsWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, params *GetApiApplicationsParams, reqEditors ...RequestEditorFn) (*GetApiApplicationsHTTP, error)

	// ListApiDocumentsWithResponse request
	ListApiDocumentsWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*ListApiDocumentsHTTP, error)

	// FetchApiDocumentWithResponse request
	FetchApiDocumentWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, documentIdOrSlug DocumentIdOrSlug, params *FetchApiDocumentParams, reqEditors ...RequestEditorFn) (*FetchApiDocumentHTTP, error)

	// ListApiSpecsWithResponse request
	ListApiSpecsWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*ListApiSpecsHTTP, error)

	// FetchApiSpecWithResponse request
	FetchApiSpecWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, specId SpecId, reqEditors ...RequestEditorFn) (*FetchApiSpecHTTP, error)

	// FetchApiSpecRawWithResponse request
	FetchApiSpecRawWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, specId SpecId, reqEditors ...RequestEditorFn) (*FetchApiSpecRawHTTP, error)

	// ListApiVersionSpecsWithResponse request
	ListApiVersionSpecsWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*ListApiVersionSpecsHTTP, error)

	// FetchApiVersionSpecWithResponse request
	FetchApiVersionSpecWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, versionId VersionId, reqEditors ...RequestEditorFn) (*FetchApiVersionSpecHTTP, error)

	// FetchApiVersionSpecRawWithResponse request
	FetchApiVersionSpecRawWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, versionId VersionId, reqEditors ...RequestEditorFn) (*FetchApiVersionSpecRawHTTP, error)

	// ListApplicationAuthStrategiesWithResponse request
	ListApplicationAuthStrategiesWithResponse(ctx context.Context, params *ListApplicationAuthStrategiesParams, reqEditors ...RequestEditorFn) (*ListApplicationAuthStrategiesHTTP, error)

	// ListApplicationsWithResponse request
	ListApplicationsWithResponse(ctx context.Context, params *ListApplicationsParams, reqEditors ...RequestEditorFn) (*ListApplicationsHTTP, error)

	// CreateApplicationWithBodyWithResponse request with any body
	CreateApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApplicationHTTP, error)

	CreateApplicationWithResponse(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApplicationHTTP, error)

	// DeleteApplicationWithResponse request
	DeleteApplicationWithResponse(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*DeleteApplicationHTTP, error)

	// GetApplicationWithResponse request
	GetApplicationWithResponse(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*GetApplicationHTTP, error)

	// UpdateApplicationWithBodyWithResponse request with any body
	UpdateApplicationWithBodyWithResponse(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApplicationHTTP, error)

	UpdateApplicationWithResponse(ctx context.Context, applicationId ApplicationId, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApplicationHTTP, error)

	// ListCredentialsWithResponse request
	ListCredentialsWithResponse(ctx context.Context, applicationId ApplicationId, params *ListCredentialsParams, reqEditors ...RequestEditorFn) (*ListCredentialsHTTP, error)

	// CreateCredentialWithBodyWithResponse request with any body
	CreateCredentialWithBodyWithResponse(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCredentialHTTP, error)

	CreateCredentialWithResponse(ctx context.Context, applicationId ApplicationId, body CreateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCredentialHTTP, error)

	// DeleteCredentialWithResponse request
	DeleteCredentialWithResponse(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, reqEditors ...RequestEditorFn) (*DeleteCredentialHTTP, error)

	// UpdateCredentialWithBodyWithResponse request with any body
	UpdateCredentialWithBodyWithResponse(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCredentialHTTP, error)

	UpdateCredentialWithResponse(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, body UpdateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCredentialHTTP, error)

	// GetApplicationGrantedScopesWithResponse request
	GetApplicationGrantedScopesWithResponse(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*GetApplicationGrantedScopesHTTP, error)

	// RegenerateApplicationSecretWithResponse request
	RegenerateApplicationSecretWithResponse(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*RegenerateApplicationSecretHTTP, error)

	// ListApplicationRegistrationsWithResponse request
	ListApplicationRegistrationsWithResponse(ctx context.Context, applicationId ApplicationId, params *ListApplicationRegistrationsParams, reqEditors ...RequestEditorFn) (*ListApplicationRegistrationsHTTP, error)

	// CreateApplicationRegistrationWithBodyWithResponse request with any body
	CreateApplicationRegistrationWithBodyWithResponse(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApplicationRegistrationHTTP, error)

	CreateApplicationRegistrationWithResponse(ctx context.Context, applicationId ApplicationId, body CreateApplicationRegistrationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApplicationRegistrationHTTP, error)

	// DeleteApplicationRegistrationWithResponse request
	DeleteApplicationRegistrationWithResponse(ctx context.Context, applicationId ApplicationId, registrationId RegistrationId, reqEditors ...RequestEditorFn) (*DeleteApplicationRegistrationHTTP, error)

	// GetApplicationRegistrationWithResponse request
	GetApplicationRegistrationWithResponse(ctx context.Context, applicationId ApplicationId, registrationId RegistrationId, reqEditors ...RequestEditorFn) (*GetApplicationRegistrationHTTP, error)

	// GetPortalFaviconWithResponse request
	GetPortalFaviconWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPortalFaviconHTTP, error)

	// GetPortalLogoWithResponse request
	GetPortalLogoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPortalLogoHTTP, error)

	// GetPortalCustomizationWithResponse request
	GetPortalCustomizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPortalCustomizationHTTP, error)

	// RegisterWithBodyWithResponse request with any body
	RegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterHTTP, error)

	RegisterWithResponse(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterHTTP, error)

	// AuthenticateWithBodyWithResponse request with any body
	AuthenticateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateHTTP, error)

	AuthenticateWithResponse(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateHTTP, error)

	// AuthenticateSsoWithResponse request
	AuthenticateSsoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthenticateSsoHTTP, error)

	// ForgotPasswordWithBodyWithResponse request with any body
	ForgotPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForgotPasswordHTTP, error)

	ForgotPasswordWithResponse(ctx context.Context, body ForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ForgotPasswordHTTP, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutHTTP, error)

	// GetDeveloperMeWithResponse request
	GetDeveloperMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDeveloperMeHTTP, error)

	// RefreshWithResponse request
	RefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshHTTP, error)

	// ResetPasswordWithBodyWithResponse request with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordHTTP, error)

	ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordHTTP, error)

	// VerifyEmailWithBodyWithResponse request with any body
	VerifyEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyEmailHTTP, error)

	VerifyEmailWithResponse(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyEmailHTTP, error)

	// ListPortalPagesWithResponse request
	ListPortalPagesWithResponse(ctx context.Context, params *ListPortalPagesParams, reqEditors ...RequestEditorFn) (*ListPortalPagesHTTP, error)

	// GetPortalPageByNameWithResponse request
	GetPortalPageByNameWithResponse(ctx context.Context, pagePath PagePath, reqEditors ...RequestEditorFn) (*GetPortalPageByNameHTTP, error)

	// GetPortalContextWithResponse request
	GetPortalContextWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPortalContextHTTP, error)

	// SearchPortalWithResponse request
	SearchPortalWithResponse(ctx context.Context, params *SearchPortalParams, reqEditors ...RequestEditorFn) (*SearchPortalHTTP, error)

	// ListPortalSnippetsWithResponse request
	ListPortalSnippetsWithResponse(ctx context.Context, params *ListPortalSnippetsParams, reqEditors ...RequestEditorFn) (*ListPortalSnippetsHTTP, error)

	// GetPortalSnippetByNameWithResponse request
	GetPortalSnippetByNameWithResponse(ctx context.Context, snippetNameParam SnippetNameParam, reqEditors ...RequestEditorFn) (*GetPortalSnippetByNameHTTP, error)

	// QueryApplicationAnalyticsWithBodyWithResponse request with any body
	QueryApplicationAnalyticsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryApplicationAnalyticsHTTP, error)

	QueryApplicationAnalyticsWithResponse(ctx context.Context, body QueryApplicationAnalyticsJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryApplicationAnalyticsHTTP, error)

	// GetApplicationAnalyticsConfigWithResponse request
	GetApplicationAnalyticsConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationAnalyticsConfigHTTP, error)
}

type GetPaginatedApiAttributesHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListApiAttributes
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetPaginatedApiAttributesHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaginatedApiAttributesHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApisHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiList
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListApisHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApisHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchApiHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiGet
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r FetchApiHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchApiHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiActionsHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiActions
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON503 *NotAvailable
}

// Status returns HTTPResponse.Status
func (r GetApiActionsHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiActionsHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiApplicationsHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiListApplications
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetApiApplicationsHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiApplicationsHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApiDocumentsHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiDocumentList
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r ListApiDocumentsHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiDocumentsHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchApiDocumentHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiDocumentGet
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r FetchApiDocumentHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchApiDocumentHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApiSpecsHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiSpecList
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r ListApiSpecsHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiSpecsHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchApiSpecHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiSpecGet
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r FetchApiSpecHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchApiSpecHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchApiSpecRawHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiSpecGetRaw
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r FetchApiSpecRawHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchApiSpecRawHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApiVersionSpecsHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiVersionList
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r ListApiVersionSpecsHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiVersionSpecsHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchApiVersionSpecHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiVersionGet
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r FetchApiVersionSpecHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchApiVersionSpecHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchApiVersionSpecRawHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApiVersionGetRaw
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r FetchApiVersionSpecRawHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchApiVersionSpecRawHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApplicationAuthStrategiesHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListAuthStrategies
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListApplicationAuthStrategiesHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApplicationAuthStrategiesHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApplicationsHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListApplications
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListApplicationsHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApplicationsHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApplicationHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *ApplicationCreation
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON409 *Conflict
}

// Status returns HTTPResponse.Status
func (r CreateApplicationHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApplicationHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApplicationHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON429 *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r DeleteApplicationHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApplicationHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetApplication
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetApplicationHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateApplicationHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ApplicationUpdate
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON409 *Conflict
}

// Status returns HTTPResponse.Status
func (r UpdateApplicationHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateApplicationHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCredentialsHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListCredentials
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON409 *Conflict
}

// Status returns HTTPResponse.Status
func (r ListCredentialsHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCredentialsHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCredentialHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CredentialCreation
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *PostCredentials403Response
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r CreateCredentialHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredentialHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCredentialHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON409 *Conflict
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCredentialHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateCredentialHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCredentialHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationGrantedScopesHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetGrantedScopesAPI
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON422 *GetGrantedScopesAPI422Response
}

// Status returns HTTPResponse.Status
func (r GetApplicationGrantedScopesHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationGrantedScopesHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegenerateApplicationSecretHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *RegenerateSecret
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r RegenerateApplicationSecretHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegenerateApplicationSecretHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApplicationRegistrationsHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListApiRegistrations
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r ListApplicationRegistrationsHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApplicationRegistrationsHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApplicationRegistrationHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateAPIRegistrationResponse
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON409 *Conflict
}

// Status returns HTTPResponse.Status
func (r CreateApplicationRegistrationHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApplicationRegistrationHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApplicationRegistrationHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteApplicationRegistrationHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApplicationRegistrationHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationRegistrationHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetAPIRegistration
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetApplicationRegistrationHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationRegistrationHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPortalFaviconHTTP struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPortalFaviconHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPortalFaviconHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPortalLogoHTTP struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPortalLogoHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPortalLogoHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPortalCustomizationHTTP struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortalCustomizationResponse
}

// Status returns HTTPResponse.Status
func (r GetPortalCustomizationHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPortalCustomizationHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
}

// Status returns HTTPResponse.Status
func (r RegisterHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticateHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r AuthenticateHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticateSsoHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
}

// Status returns HTTPResponse.Status
func (r AuthenticateSsoHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateSsoHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ForgotPasswordHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
}

// Status returns HTTPResponse.Status
func (r ForgotPasswordHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ForgotPasswordHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutHTTP struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogoutHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeveloperMeHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MeResponse
	ApplicationproblemJSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetDeveloperMeHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeveloperMeHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *ResponsesUnauthorized
}

// Status returns HTTPResponse.Status
func (r RefreshHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *ResponsesUnauthorized
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON410 *Gone
}

// Status returns HTTPResponse.Status
func (r ResetPasswordHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyEmailHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *VerifyEmailResponse
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON410 *Gone
}

// Status returns HTTPResponse.Status
func (r VerifyEmailHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyEmailHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPortalPagesHTTP struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPortalPagesResponse
}

// Status returns HTTPResponse.Status
func (r ListPortalPagesHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPortalPagesHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPortalPageByNameHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetPortalPageResponse
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetPortalPageByNameHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPortalPageByNameHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPortalContextHTTP struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPortalContextResponse
}

// Status returns HTTPResponse.Status
func (r GetPortalContextHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPortalContextHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPortalHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PortalSearchResponse
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r SearchPortalHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPortalHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPortalSnippetsHTTP struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPortalSnippetsResponse
}

// Status returns HTTPResponse.Status
func (r ListPortalSnippetsHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPortalSnippetsHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPortalSnippetByNameHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetPortalSnippetResponse
	ApplicationproblemJSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetPortalSnippetByNameHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPortalSnippetByNameHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryApplicationAnalyticsHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *QueryResponse
	ApplicationproblemJSON403 *Forbidden
}

// Status returns HTTPResponse.Status
func (r QueryApplicationAnalyticsHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryApplicationAnalyticsHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationAnalyticsConfigHTTP struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetConfig
	ApplicationproblemJSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetApplicationAnalyticsConfigHTTP) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationAnalyticsConfigHTTP) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetPaginatedApiAttributesWithResponse request returning *GetPaginatedApiAttributesHTTP
func (c *ClientWithResponses) GetPaginatedApiAttributesWithResponse(ctx context.Context, params *GetPaginatedApiAttributesParams, reqEditors ...RequestEditorFn) (*GetPaginatedApiAttributesHTTP, error) {
	rsp, err := c.GetPaginatedApiAttributes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaginatedApiAttributesHTTP(rsp)
}

// ListApisWithResponse request returning *ListApisHTTP
func (c *ClientWithResponses) ListApisWithResponse(ctx context.Context, params *ListApisParams, reqEditors ...RequestEditorFn) (*ListApisHTTP, error) {
	rsp, err := c.ListApis(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApisHTTP(rsp)
}

// FetchApiWithResponse request returning *FetchApiHTTP
func (c *ClientWithResponses) FetchApiWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*FetchApiHTTP, error) {
	rsp, err := c.FetchApi(ctx, apiIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchApiHTTP(rsp)
}

// GetApiActionsWithResponse request returning *GetApiActionsHTTP
func (c *ClientWithResponses) GetApiActionsWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*GetApiActionsHTTP, error) {
	rsp, err := c.GetApiActions(ctx, apiIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiActionsHTTP(rsp)
}

// GetApiApplicationsWithResponse request returning *GetApiApplicationsHTTP
func (c *ClientWithResponses) GetApiApplicationsWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, params *GetApiApplicationsParams, reqEditors ...RequestEditorFn) (*GetApiApplicationsHTTP, error) {
	rsp, err := c.GetApiApplications(ctx, apiIdOrSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiApplicationsHTTP(rsp)
}

// ListApiDocumentsWithResponse request returning *ListApiDocumentsHTTP
func (c *ClientWithResponses) ListApiDocumentsWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*ListApiDocumentsHTTP, error) {
	rsp, err := c.ListApiDocuments(ctx, apiIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiDocumentsHTTP(rsp)
}

// FetchApiDocumentWithResponse request returning *FetchApiDocumentHTTP
func (c *ClientWithResponses) FetchApiDocumentWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, documentIdOrSlug DocumentIdOrSlug, params *FetchApiDocumentParams, reqEditors ...RequestEditorFn) (*FetchApiDocumentHTTP, error) {
	rsp, err := c.FetchApiDocument(ctx, apiIdOrSlug, documentIdOrSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchApiDocumentHTTP(rsp)
}

// ListApiSpecsWithResponse request returning *ListApiSpecsHTTP
func (c *ClientWithResponses) ListApiSpecsWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*ListApiSpecsHTTP, error) {
	rsp, err := c.ListApiSpecs(ctx, apiIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiSpecsHTTP(rsp)
}

// FetchApiSpecWithResponse request returning *FetchApiSpecHTTP
func (c *ClientWithResponses) FetchApiSpecWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, specId SpecId, reqEditors ...RequestEditorFn) (*FetchApiSpecHTTP, error) {
	rsp, err := c.FetchApiSpec(ctx, apiIdOrSlug, specId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchApiSpecHTTP(rsp)
}

// FetchApiSpecRawWithResponse request returning *FetchApiSpecRawHTTP
func (c *ClientWithResponses) FetchApiSpecRawWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, specId SpecId, reqEditors ...RequestEditorFn) (*FetchApiSpecRawHTTP, error) {
	rsp, err := c.FetchApiSpecRaw(ctx, apiIdOrSlug, specId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchApiSpecRawHTTP(rsp)
}

// ListApiVersionSpecsWithResponse request returning *ListApiVersionSpecsHTTP
func (c *ClientWithResponses) ListApiVersionSpecsWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, reqEditors ...RequestEditorFn) (*ListApiVersionSpecsHTTP, error) {
	rsp, err := c.ListApiVersionSpecs(ctx, apiIdOrSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiVersionSpecsHTTP(rsp)
}

// FetchApiVersionSpecWithResponse request returning *FetchApiVersionSpecHTTP
func (c *ClientWithResponses) FetchApiVersionSpecWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, versionId VersionId, reqEditors ...RequestEditorFn) (*FetchApiVersionSpecHTTP, error) {
	rsp, err := c.FetchApiVersionSpec(ctx, apiIdOrSlug, versionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchApiVersionSpecHTTP(rsp)
}

// FetchApiVersionSpecRawWithResponse request returning *FetchApiVersionSpecRawHTTP
func (c *ClientWithResponses) FetchApiVersionSpecRawWithResponse(ctx context.Context, apiIdOrSlug ApiIdOrSlug, versionId VersionId, reqEditors ...RequestEditorFn) (*FetchApiVersionSpecRawHTTP, error) {
	rsp, err := c.FetchApiVersionSpecRaw(ctx, apiIdOrSlug, versionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchApiVersionSpecRawHTTP(rsp)
}

// ListApplicationAuthStrategiesWithResponse request returning *ListApplicationAuthStrategiesHTTP
func (c *ClientWithResponses) ListApplicationAuthStrategiesWithResponse(ctx context.Context, params *ListApplicationAuthStrategiesParams, reqEditors ...RequestEditorFn) (*ListApplicationAuthStrategiesHTTP, error) {
	rsp, err := c.ListApplicationAuthStrategies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApplicationAuthStrategiesHTTP(rsp)
}

// ListApplicationsWithResponse request returning *ListApplicationsHTTP
func (c *ClientWithResponses) ListApplicationsWithResponse(ctx context.Context, params *ListApplicationsParams, reqEditors ...RequestEditorFn) (*ListApplicationsHTTP, error) {
	rsp, err := c.ListApplications(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApplicationsHTTP(rsp)
}

// CreateApplicationWithBodyWithResponse request with arbitrary body returning *CreateApplicationHTTP
func (c *ClientWithResponses) CreateApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApplicationHTTP, error) {
	rsp, err := c.CreateApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApplicationHTTP(rsp)
}

func (c *ClientWithResponses) CreateApplicationWithResponse(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApplicationHTTP, error) {
	rsp, err := c.CreateApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApplicationHTTP(rsp)
}

// DeleteApplicationWithResponse request returning *DeleteApplicationHTTP
func (c *ClientWithResponses) DeleteApplicationWithResponse(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*DeleteApplicationHTTP, error) {
	rsp, err := c.DeleteApplication(ctx, applicationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApplicationHTTP(rsp)
}

// GetApplicationWithResponse request returning *GetApplicationHTTP
func (c *ClientWithResponses) GetApplicationWithResponse(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*GetApplicationHTTP, error) {
	rsp, err := c.GetApplication(ctx, applicationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationHTTP(rsp)
}

// UpdateApplicationWithBodyWithResponse request with arbitrary body returning *UpdateApplicationHTTP
func (c *ClientWithResponses) UpdateApplicationWithBodyWithResponse(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApplicationHTTP, error) {
	rsp, err := c.UpdateApplicationWithBody(ctx, applicationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApplicationHTTP(rsp)
}

func (c *ClientWithResponses) UpdateApplicationWithResponse(ctx context.Context, applicationId ApplicationId, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApplicationHTTP, error) {
	rsp, err := c.UpdateApplication(ctx, applicationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApplicationHTTP(rsp)
}

// ListCredentialsWithResponse request returning *ListCredentialsHTTP
func (c *ClientWithResponses) ListCredentialsWithResponse(ctx context.Context, applicationId ApplicationId, params *ListCredentialsParams, reqEditors ...RequestEditorFn) (*ListCredentialsHTTP, error) {
	rsp, err := c.ListCredentials(ctx, applicationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCredentialsHTTP(rsp)
}

// CreateCredentialWithBodyWithResponse request with arbitrary body returning *CreateCredentialHTTP
func (c *ClientWithResponses) CreateCredentialWithBodyWithResponse(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCredentialHTTP, error) {
	rsp, err := c.CreateCredentialWithBody(ctx, applicationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCredentialHTTP(rsp)
}

func (c *ClientWithResponses) CreateCredentialWithResponse(ctx context.Context, applicationId ApplicationId, body CreateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCredentialHTTP, error) {
	rsp, err := c.CreateCredential(ctx, applicationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCredentialHTTP(rsp)
}

// DeleteCredentialWithResponse request returning *DeleteCredentialHTTP
func (c *ClientWithResponses) DeleteCredentialWithResponse(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, reqEditors ...RequestEditorFn) (*DeleteCredentialHTTP, error) {
	rsp, err := c.DeleteCredential(ctx, applicationId, credentialId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCredentialHTTP(rsp)
}

// UpdateCredentialWithBodyWithResponse request with arbitrary body returning *UpdateCredentialHTTP
func (c *ClientWithResponses) UpdateCredentialWithBodyWithResponse(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCredentialHTTP, error) {
	rsp, err := c.UpdateCredentialWithBody(ctx, applicationId, credentialId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCredentialHTTP(rsp)
}

func (c *ClientWithResponses) UpdateCredentialWithResponse(ctx context.Context, applicationId ApplicationId, credentialId CredentialId, body UpdateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCredentialHTTP, error) {
	rsp, err := c.UpdateCredential(ctx, applicationId, credentialId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCredentialHTTP(rsp)
}

// GetApplicationGrantedScopesWithResponse request returning *GetApplicationGrantedScopesHTTP
func (c *ClientWithResponses) GetApplicationGrantedScopesWithResponse(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*GetApplicationGrantedScopesHTTP, error) {
	rsp, err := c.GetApplicationGrantedScopes(ctx, applicationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationGrantedScopesHTTP(rsp)
}

// RegenerateApplicationSecretWithResponse request returning *RegenerateApplicationSecretHTTP
func (c *ClientWithResponses) RegenerateApplicationSecretWithResponse(ctx context.Context, applicationId ApplicationId, reqEditors ...RequestEditorFn) (*RegenerateApplicationSecretHTTP, error) {
	rsp, err := c.RegenerateApplicationSecret(ctx, applicationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegenerateApplicationSecretHTTP(rsp)
}

// ListApplicationRegistrationsWithResponse request returning *ListApplicationRegistrationsHTTP
func (c *ClientWithResponses) ListApplicationRegistrationsWithResponse(ctx context.Context, applicationId ApplicationId, params *ListApplicationRegistrationsParams, reqEditors ...RequestEditorFn) (*ListApplicationRegistrationsHTTP, error) {
	rsp, err := c.ListApplicationRegistrations(ctx, applicationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApplicationRegistrationsHTTP(rsp)
}

// CreateApplicationRegistrationWithBodyWithResponse request with arbitrary body returning *CreateApplicationRegistrationHTTP
func (c *ClientWithResponses) CreateApplicationRegistrationWithBodyWithResponse(ctx context.Context, applicationId ApplicationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApplicationRegistrationHTTP, error) {
	rsp, err := c.CreateApplicationRegistrationWithBody(ctx, applicationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApplicationRegistrationHTTP(rsp)
}

func (c *ClientWithResponses) CreateApplicationRegistrationWithResponse(ctx context.Context, applicationId ApplicationId, body CreateApplicationRegistrationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApplicationRegistrationHTTP, error) {
	rsp, err := c.CreateApplicationRegistration(ctx, applicationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApplicationRegistrationHTTP(rsp)
}

// DeleteApplicationRegistrationWithResponse request returning *DeleteApplicationRegistrationHTTP
func (c *ClientWithResponses) DeleteApplicationRegistrationWithResponse(ctx context.Context, applicationId ApplicationId, registrationId RegistrationId, reqEditors ...RequestEditorFn) (*DeleteApplicationRegistrationHTTP, error) {
	rsp, err := c.DeleteApplicationRegistration(ctx, applicationId, registrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApplicationRegistrationHTTP(rsp)
}

// GetApplicationRegistrationWithResponse request returning *GetApplicationRegistrationHTTP
func (c *ClientWithResponses) GetApplicationRegistrationWithResponse(ctx context.Context, applicationId ApplicationId, registrationId RegistrationId, reqEditors ...RequestEditorFn) (*GetApplicationRegistrationHTTP, error) {
	rsp, err := c.GetApplicationRegistration(ctx, applicationId, registrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationRegistrationHTTP(rsp)
}

// GetPortalFaviconWithResponse request returning *GetPortalFaviconHTTP
func (c *ClientWithResponses) GetPortalFaviconWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPortalFaviconHTTP, error) {
	rsp, err := c.GetPortalFavicon(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPortalFaviconHTTP(rsp)
}

// GetPortalLogoWithResponse request returning *GetPortalLogoHTTP
func (c *ClientWithResponses) GetPortalLogoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPortalLogoHTTP, error) {
	rsp, err := c.GetPortalLogo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPortalLogoHTTP(rsp)
}

// GetPortalCustomizationWithResponse request returning *GetPortalCustomizationHTTP
func (c *ClientWithResponses) GetPortalCustomizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPortalCustomizationHTTP, error) {
	rsp, err := c.GetPortalCustomization(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPortalCustomizationHTTP(rsp)
}

// RegisterWithBodyWithResponse request with arbitrary body returning *RegisterHTTP
func (c *ClientWithResponses) RegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterHTTP, error) {
	rsp, err := c.RegisterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterHTTP(rsp)
}

func (c *ClientWithResponses) RegisterWithResponse(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterHTTP, error) {
	rsp, err := c.Register(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterHTTP(rsp)
}

// AuthenticateWithBodyWithResponse request with arbitrary body returning *AuthenticateHTTP
func (c *ClientWithResponses) AuthenticateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateHTTP, error) {
	rsp, err := c.AuthenticateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateHTTP(rsp)
}

func (c *ClientWithResponses) AuthenticateWithResponse(ctx context.Context, body AuthenticateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateHTTP, error) {
	rsp, err := c.Authenticate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateHTTP(rsp)
}

// AuthenticateSsoWithResponse request returning *AuthenticateSsoHTTP
func (c *ClientWithResponses) AuthenticateSsoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthenticateSsoHTTP, error) {
	rsp, err := c.AuthenticateSso(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateSsoHTTP(rsp)
}

// ForgotPasswordWithBodyWithResponse request with arbitrary body returning *ForgotPasswordHTTP
func (c *ClientWithResponses) ForgotPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForgotPasswordHTTP, error) {
	rsp, err := c.ForgotPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForgotPasswordHTTP(rsp)
}

func (c *ClientWithResponses) ForgotPasswordWithResponse(ctx context.Context, body ForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ForgotPasswordHTTP, error) {
	rsp, err := c.ForgotPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForgotPasswordHTTP(rsp)
}

// LogoutWithResponse request returning *LogoutHTTP
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutHTTP, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutHTTP(rsp)
}

// GetDeveloperMeWithResponse request returning *GetDeveloperMeHTTP
func (c *ClientWithResponses) GetDeveloperMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDeveloperMeHTTP, error) {
	rsp, err := c.GetDeveloperMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeveloperMeHTTP(rsp)
}

// RefreshWithResponse request returning *RefreshHTTP
func (c *ClientWithResponses) RefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshHTTP, error) {
	rsp, err := c.Refresh(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshHTTP(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordHTTP
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordHTTP, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordHTTP(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordHTTP, error) {
	rsp, err := c.ResetPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordHTTP(rsp)
}

// VerifyEmailWithBodyWithResponse request with arbitrary body returning *VerifyEmailHTTP
func (c *ClientWithResponses) VerifyEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyEmailHTTP, error) {
	rsp, err := c.VerifyEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyEmailHTTP(rsp)
}

func (c *ClientWithResponses) VerifyEmailWithResponse(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyEmailHTTP, error) {
	rsp, err := c.VerifyEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyEmailHTTP(rsp)
}

// ListPortalPagesWithResponse request returning *ListPortalPagesHTTP
func (c *ClientWithResponses) ListPortalPagesWithResponse(ctx context.Context, params *ListPortalPagesParams, reqEditors ...RequestEditorFn) (*ListPortalPagesHTTP, error) {
	rsp, err := c.ListPortalPages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPortalPagesHTTP(rsp)
}

// GetPortalPageByNameWithResponse request returning *GetPortalPageByNameHTTP
func (c *ClientWithResponses) GetPortalPageByNameWithResponse(ctx context.Context, pagePath PagePath, reqEditors ...RequestEditorFn) (*GetPortalPageByNameHTTP, error) {
	rsp, err := c.GetPortalPageByName(ctx, pagePath, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPortalPageByNameHTTP(rsp)
}

// GetPortalContextWithResponse request returning *GetPortalContextHTTP
func (c *ClientWithResponses) GetPortalContextWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPortalContextHTTP, error) {
	rsp, err := c.GetPortalContext(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPortalContextHTTP(rsp)
}

// SearchPortalWithResponse request returning *SearchPortalHTTP
func (c *ClientWithResponses) SearchPortalWithResponse(ctx context.Context, params *SearchPortalParams, reqEditors ...RequestEditorFn) (*SearchPortalHTTP, error) {
	rsp, err := c.SearchPortal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPortalHTTP(rsp)
}

// ListPortalSnippetsWithResponse request returning *ListPortalSnippetsHTTP
func (c *ClientWithResponses) ListPortalSnippetsWithResponse(ctx context.Context, params *ListPortalSnippetsParams, reqEditors ...RequestEditorFn) (*ListPortalSnippetsHTTP, error) {
	rsp, err := c.ListPortalSnippets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPortalSnippetsHTTP(rsp)
}

// GetPortalSnippetByNameWithResponse request returning *GetPortalSnippetByNameHTTP
func (c *ClientWithResponses) GetPortalSnippetByNameWithResponse(ctx context.Context, snippetNameParam SnippetNameParam, reqEditors ...RequestEditorFn) (*GetPortalSnippetByNameHTTP, error) {
	rsp, err := c.GetPortalSnippetByName(ctx, snippetNameParam, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPortalSnippetByNameHTTP(rsp)
}

// QueryApplicationAnalyticsWithBodyWithResponse request with arbitrary body returning *QueryApplicationAnalyticsHTTP
func (c *ClientWithResponses) QueryApplicationAnalyticsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryApplicationAnalyticsHTTP, error) {
	rsp, err := c.QueryApplicationAnalyticsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryApplicationAnalyticsHTTP(rsp)
}

func (c *ClientWithResponses) QueryApplicationAnalyticsWithResponse(ctx context.Context, body QueryApplicationAnalyticsJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryApplicationAnalyticsHTTP, error) {
	rsp, err := c.QueryApplicationAnalytics(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryApplicationAnalyticsHTTP(rsp)
}

// GetApplicationAnalyticsConfigWithResponse request returning *GetApplicationAnalyticsConfigHTTP
func (c *ClientWithResponses) GetApplicationAnalyticsConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApplicationAnalyticsConfigHTTP, error) {
	rsp, err := c.GetApplicationAnalyticsConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationAnalyticsConfigHTTP(rsp)
}

// ParseGetPaginatedApiAttributesHTTP parses an HTTP response from a GetPaginatedApiAttributesWithResponse call
func ParseGetPaginatedApiAttributesHTTP(rsp *http.Response) (*GetPaginatedApiAttributesHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaginatedApiAttributesHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListApiAttributes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseListApisHTTP parses an HTTP response from a ListApisWithResponse call
func ParseListApisHTTP(rsp *http.Response) (*ListApisHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApisHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	}

	return response, nil
}

// ParseFetchApiHTTP parses an HTTP response from a FetchApiWithResponse call
func ParseFetchApiHTTP(rsp *http.Response) (*FetchApiHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchApiHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseGetApiActionsHTTP parses an HTTP response from a GetApiActionsWithResponse call
func ParseGetApiActionsHTTP(rsp *http.Response) (*GetApiActionsHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiActionsHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiActions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest NotAvailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetApiApplicationsHTTP parses an HTTP response from a GetApiApplicationsWithResponse call
func ParseGetApiApplicationsHTTP(rsp *http.Response) (*GetApiApplicationsHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiApplicationsHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiListApplications
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseListApiDocumentsHTTP parses an HTTP response from a ListApiDocumentsWithResponse call
func ParseListApiDocumentsHTTP(rsp *http.Response) (*ListApiDocumentsHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiDocumentsHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiDocumentList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseFetchApiDocumentHTTP parses an HTTP response from a FetchApiDocumentWithResponse call
func ParseFetchApiDocumentHTTP(rsp *http.Response) (*FetchApiDocumentHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchApiDocumentHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiDocumentGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseListApiSpecsHTTP parses an HTTP response from a ListApiSpecsWithResponse call
func ParseListApiSpecsHTTP(rsp *http.Response) (*ListApiSpecsHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiSpecsHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiSpecList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseFetchApiSpecHTTP parses an HTTP response from a FetchApiSpecWithResponse call
func ParseFetchApiSpecHTTP(rsp *http.Response) (*FetchApiSpecHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchApiSpecHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiSpecGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseFetchApiSpecRawHTTP parses an HTTP response from a FetchApiSpecRawWithResponse call
func ParseFetchApiSpecRawHTTP(rsp *http.Response) (*FetchApiSpecRawHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchApiSpecRawHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiSpecGetRaw
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseListApiVersionSpecsHTTP parses an HTTP response from a ListApiVersionSpecsWithResponse call
func ParseListApiVersionSpecsHTTP(rsp *http.Response) (*ListApiVersionSpecsHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiVersionSpecsHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiVersionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseFetchApiVersionSpecHTTP parses an HTTP response from a FetchApiVersionSpecWithResponse call
func ParseFetchApiVersionSpecHTTP(rsp *http.Response) (*FetchApiVersionSpecHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchApiVersionSpecHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiVersionGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseFetchApiVersionSpecRawHTTP parses an HTTP response from a FetchApiVersionSpecRawWithResponse call
func ParseFetchApiVersionSpecRawHTTP(rsp *http.Response) (*FetchApiVersionSpecRawHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchApiVersionSpecRawHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiVersionGetRaw
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseListApplicationAuthStrategiesHTTP parses an HTTP response from a ListApplicationAuthStrategiesWithResponse call
func ParseListApplicationAuthStrategiesHTTP(rsp *http.Response) (*ListApplicationAuthStrategiesHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApplicationAuthStrategiesHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAuthStrategies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	}

	return response, nil
}

// ParseListApplicationsHTTP parses an HTTP response from a ListApplicationsWithResponse call
func ParseListApplicationsHTTP(rsp *http.Response) (*ListApplicationsHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApplicationsHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListApplications
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	}

	return response, nil
}

// ParseCreateApplicationHTTP parses an HTTP response from a CreateApplicationWithResponse call
func ParseCreateApplicationHTTP(rsp *http.Response) (*CreateApplicationHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApplicationHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApplicationCreation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	}

	return response, nil
}

// ParseDeleteApplicationHTTP parses an HTTP response from a DeleteApplicationWithResponse call
func ParseDeleteApplicationHTTP(rsp *http.Response) (*DeleteApplicationHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApplicationHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	}

	return response, nil
}

// ParseGetApplicationHTTP parses an HTTP response from a GetApplicationWithResponse call
func ParseGetApplicationHTTP(rsp *http.Response) (*GetApplicationHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetApplication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseUpdateApplicationHTTP parses an HTTP response from a UpdateApplicationWithResponse call
func ParseUpdateApplicationHTTP(rsp *http.Response) (*UpdateApplicationHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateApplicationHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationUpdate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	}

	return response, nil
}

// ParseListCredentialsHTTP parses an HTTP response from a ListCredentialsWithResponse call
func ParseListCredentialsHTTP(rsp *http.Response) (*ListCredentialsHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCredentialsHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	}

	return response, nil
}

// ParseCreateCredentialHTTP parses an HTTP response from a CreateCredentialWithResponse call
func ParseCreateCredentialHTTP(rsp *http.Response) (*CreateCredentialHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCredentialHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CredentialCreation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostCredentials403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseDeleteCredentialHTTP parses an HTTP response from a DeleteCredentialWithResponse call
func ParseDeleteCredentialHTTP(rsp *http.Response) (*DeleteCredentialHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCredentialHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	}

	return response, nil
}

// ParseUpdateCredentialHTTP parses an HTTP response from a UpdateCredentialWithResponse call
func ParseUpdateCredentialHTTP(rsp *http.Response) (*UpdateCredentialHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCredentialHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseGetApplicationGrantedScopesHTTP parses an HTTP response from a GetApplicationGrantedScopesWithResponse call
func ParseGetApplicationGrantedScopesHTTP(rsp *http.Response) (*GetApplicationGrantedScopesHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationGrantedScopesHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGrantedScopesAPI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest GetGrantedScopesAPI422Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON422 = &dest

	}

	return response, nil
}

// ParseRegenerateApplicationSecretHTTP parses an HTTP response from a RegenerateApplicationSecretWithResponse call
func ParseRegenerateApplicationSecretHTTP(rsp *http.Response) (*RegenerateApplicationSecretHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegenerateApplicationSecretHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RegenerateSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseListApplicationRegistrationsHTTP parses an HTTP response from a ListApplicationRegistrationsWithResponse call
func ParseListApplicationRegistrationsHTTP(rsp *http.Response) (*ListApplicationRegistrationsHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApplicationRegistrationsHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListApiRegistrations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseCreateApplicationRegistrationHTTP parses an HTTP response from a CreateApplicationRegistrationWithResponse call
func ParseCreateApplicationRegistrationHTTP(rsp *http.Response) (*CreateApplicationRegistrationHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApplicationRegistrationHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateAPIRegistrationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	}

	return response, nil
}

// ParseDeleteApplicationRegistrationHTTP parses an HTTP response from a DeleteApplicationRegistrationWithResponse call
func ParseDeleteApplicationRegistrationHTTP(rsp *http.Response) (*DeleteApplicationRegistrationHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApplicationRegistrationHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseGetApplicationRegistrationHTTP parses an HTTP response from a GetApplicationRegistrationWithResponse call
func ParseGetApplicationRegistrationHTTP(rsp *http.Response) (*GetApplicationRegistrationHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationRegistrationHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAPIRegistration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseGetPortalFaviconHTTP parses an HTTP response from a GetPortalFaviconWithResponse call
func ParseGetPortalFaviconHTTP(rsp *http.Response) (*GetPortalFaviconHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPortalFaviconHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPortalLogoHTTP parses an HTTP response from a GetPortalLogoWithResponse call
func ParseGetPortalLogoHTTP(rsp *http.Response) (*GetPortalLogoHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPortalLogoHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPortalCustomizationHTTP parses an HTTP response from a GetPortalCustomizationWithResponse call
func ParseGetPortalCustomizationHTTP(rsp *http.Response) (*GetPortalCustomizationHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPortalCustomizationHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortalCustomizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegisterHTTP parses an HTTP response from a RegisterWithResponse call
func ParseRegisterHTTP(rsp *http.Response) (*RegisterHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseAuthenticateHTTP parses an HTTP response from a AuthenticateWithResponse call
func ParseAuthenticateHTTP(rsp *http.Response) (*AuthenticateHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseAuthenticateSsoHTTP parses an HTTP response from a AuthenticateSsoWithResponse call
func ParseAuthenticateSsoHTTP(rsp *http.Response) (*AuthenticateSsoHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateSsoHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseForgotPasswordHTTP parses an HTTP response from a ForgotPasswordWithResponse call
func ParseForgotPasswordHTTP(rsp *http.Response) (*ForgotPasswordHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ForgotPasswordHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	}

	return response, nil
}

// ParseLogoutHTTP parses an HTTP response from a LogoutWithResponse call
func ParseLogoutHTTP(rsp *http.Response) (*LogoutHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDeveloperMeHTTP parses an HTTP response from a GetDeveloperMeWithResponse call
func ParseGetDeveloperMeHTTP(rsp *http.Response) (*GetDeveloperMeHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeveloperMeHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	}

	return response, nil
}

// ParseRefreshHTTP parses an HTTP response from a RefreshWithResponse call
func ParseRefreshHTTP(rsp *http.Response) (*RefreshHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ResponsesUnauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	}

	return response, nil
}

// ParseResetPasswordHTTP parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordHTTP(rsp *http.Response) (*ResetPasswordHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ResponsesUnauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Gone
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	}

	return response, nil
}

// ParseVerifyEmailHTTP parses an HTTP response from a VerifyEmailWithResponse call
func ParseVerifyEmailHTTP(rsp *http.Response) (*VerifyEmailHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyEmailHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VerifyEmailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Gone
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON410 = &dest

	}

	return response, nil
}

// ParseListPortalPagesHTTP parses an HTTP response from a ListPortalPagesWithResponse call
func ParseListPortalPagesHTTP(rsp *http.Response) (*ListPortalPagesHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPortalPagesHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPortalPagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPortalPageByNameHTTP parses an HTTP response from a GetPortalPageByNameWithResponse call
func ParseGetPortalPageByNameHTTP(rsp *http.Response) (*GetPortalPageByNameHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPortalPageByNameHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPortalPageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseGetPortalContextHTTP parses an HTTP response from a GetPortalContextWithResponse call
func ParseGetPortalContextHTTP(rsp *http.Response) (*GetPortalContextHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPortalContextHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPortalContextResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchPortalHTTP parses an HTTP response from a SearchPortalWithResponse call
func ParseSearchPortalHTTP(rsp *http.Response) (*SearchPortalHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPortalHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortalSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	}

	return response, nil
}

// ParseListPortalSnippetsHTTP parses an HTTP response from a ListPortalSnippetsWithResponse call
func ParseListPortalSnippetsHTTP(rsp *http.Response) (*ListPortalSnippetsHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPortalSnippetsHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPortalSnippetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPortalSnippetByNameHTTP parses an HTTP response from a GetPortalSnippetByNameWithResponse call
func ParseGetPortalSnippetByNameHTTP(rsp *http.Response) (*GetPortalSnippetByNameHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPortalSnippetByNameHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPortalSnippetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseQueryApplicationAnalyticsHTTP parses an HTTP response from a QueryApplicationAnalyticsWithResponse call
func ParseQueryApplicationAnalyticsHTTP(rsp *http.Response) (*QueryApplicationAnalyticsHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryApplicationAnalyticsHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	}

	return response, nil
}

// ParseGetApplicationAnalyticsConfigHTTP parses an HTTP response from a GetApplicationAnalyticsConfigWithResponse call
func ParseGetApplicationAnalyticsConfigHTTP(rsp *http.Response) (*GetApplicationAnalyticsConfigHTTP, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationAnalyticsConfigHTTP{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	}

	return response, nil
}
